<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Procedural Game Plot Generation Prototype: source/dlib/algs.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>source/dlib/algs.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright (C) 2003  Davis E. King (davis@dlib.net)</span>
<a name="l00002"></a>00002 <span class="comment">// License: Boost Software License   See LICENSE.txt for the full license.</span>
<a name="l00003"></a>00003 <span class="preprocessor">#ifndef DLIB_ALGs_</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#define DLIB_ALGs_</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span>
<a name="l00006"></a>00006 <span class="comment">// this file contains miscellaneous stuff                      </span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="comment">// Disable the following warnings for Visual Studio</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">// this is to disable the &quot;&apos;this&apos; : used in base member initializer list&quot;</span>
<a name="l00013"></a>00013 <span class="comment">// warning you get from some of the GUI objects since all the objects</span>
<a name="l00014"></a>00014 <span class="comment">// require that their parent class be passed into their constructor. </span>
<a name="l00015"></a>00015 <span class="comment">// In this case though it is totally safe so it is ok to disable this warning.</span>
<a name="l00016"></a>00016 <span class="preprocessor">#pragma warning(disable : 4355)</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 <span class="comment">// This is a warning you get sometimes when Visual Studio performs a Koenig Lookup. </span>
<a name="l00019"></a>00019 <span class="comment">// This is a bug in visual studio.  It is a totally legitimate thing to </span>
<a name="l00020"></a>00020 <span class="comment">// expect from a compiler. </span>
<a name="l00021"></a>00021 <span class="preprocessor">#pragma warning(disable : 4675)</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="comment">// This is a warning you get from visual studio 2005 about things in the standard C++</span>
<a name="l00024"></a>00024 <span class="comment">// library being &quot;deprecated.&quot;  I checked the C++ standard and it doesn&apos;t say jack </span>
<a name="l00025"></a>00025 <span class="comment">// about any of them (I checked the searchable PDF).   So this warning is total Bunk.</span>
<a name="l00026"></a>00026 <span class="preprocessor">#pragma warning(disable : 4996)</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="comment">// This is a warning you get from visual studio 2003:</span>
<a name="l00029"></a>00029 <span class="comment">//    warning C4345: behavior change: an object of POD type constructed with an initializer </span>
<a name="l00030"></a>00030 <span class="comment">//    of the form () will be default-initialized.</span>
<a name="l00031"></a>00031 <span class="comment">// I love it when this compiler gives warnings about bugs in previous versions of itself. </span>
<a name="l00032"></a>00032 <span class="preprocessor">#pragma warning(disable : 4345)</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">// Disable warnings about conversion from size_t to unsigned long and long.</span>
<a name="l00036"></a>00036 <span class="preprocessor">#pragma warning(disable : 4267)</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="comment">// Disable warnings about conversion from double to float  </span>
<a name="l00039"></a>00039 <span class="preprocessor">#pragma warning(disable : 4244)</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable : 4305)</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="preprocessor">#endif</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef __BORLANDC__</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="comment">// Disable the following warnings for the Borland Compilers</span>
<a name="l00046"></a>00046 <span class="comment">//</span>
<a name="l00047"></a>00047 <span class="comment">// These warnings just say that the compiler is refusing to inline functions with</span>
<a name="l00048"></a>00048 <span class="comment">// loops or try blocks in them.  </span>
<a name="l00049"></a>00049 <span class="comment">//</span>
<a name="l00050"></a>00050 <span class="preprocessor">#pragma option -w-8027</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#pragma option -w-8026 </span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;string&gt;</span>       <span class="comment">// for the exceptions</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="preprocessor">#ifdef __CYGWIN__</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="keyword">namespace </span>std
<a name="l00058"></a>00058 {
<a name="l00059"></a>00059    <span class="keyword">typedef</span> std::basic_string&lt;wchar_t&gt; wstring;
<a name="l00060"></a>00060 }
<a name="l00061"></a>00061 <span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;platform.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;windows_magic.h&quot;</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;algorithm&gt;</span>    <span class="comment">// for std::swap</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;new&gt;</span>          <span class="comment">// for std::bad_alloc</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;assert.h&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;error.h&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &quot;noncopyable.h&quot;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &quot;enable_if.h&quot;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &quot;uintn.h&quot;</span>
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00081"></a>00081 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keywordtype">char</span>T&gt;
<a name="l00082"></a>00082 <span class="keyword">inline</span> charT _dTcast (<span class="keyword">const</span> <span class="keywordtype">char</span> a, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> b);
<a name="l00083"></a>00083 <span class="keyword">template</span> &lt;&gt;
<a name="l00084"></a>00084 <span class="keyword">inline</span> <span class="keywordtype">char</span> _dTcast&lt;char&gt; (<span class="keyword">const</span> <span class="keywordtype">char</span> a, <span class="keyword">const</span> wchar_t ) { <span class="keywordflow">return</span> a; }
<a name="l00085"></a>00085 <span class="keyword">template</span> &lt;&gt;
<a name="l00086"></a>00086 <span class="keyword">inline</span> <span class="keywordtype">wchar_t</span> _dTcast&lt;wchar_t&gt; (<span class="keyword">const</span> char , <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> b) { <span class="keywordflow">return</span> b; }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keywordtype">char</span>T&gt;
<a name="l00089"></a>00089 <span class="keyword">inline</span> <span class="keyword">const</span> charT* _dTcast ( <span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* b);
<a name="l00090"></a>00090 <span class="keyword">template</span> &lt;&gt;
<a name="l00091"></a>00091 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* _dTcast&lt;char&gt; ( <span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* ) { <span class="keywordflow">return</span> a; }
<a name="l00092"></a>00092 <span class="keyword">template</span> &lt;&gt;
<a name="l00093"></a>00093 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* _dTcast&lt;wchar_t&gt; ( <span class="keyword">const</span> <span class="keywordtype">char</span>* , <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* b) { <span class="keywordflow">return</span> b; }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="preprocessor">#define _dT(charT,str) _dTcast&lt;charT&gt;(str,L##str) </span>
<a name="l00097"></a>00097 <span class="preprocessor"></span>
<a name="l00105"></a>00105 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00109"></a><a class="code" href="namespacedlib.html">00109</a> <span class="keyword">namespace </span>dlib
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00113"></a>00113 
<a name="l00115"></a>00115     <span class="comment">// make swap available in the dlib namespace</span>
<a name="l00116"></a>00116     <span class="keyword">using</span> std::swap;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00119"></a>00119 
<a name="l00125"></a><a class="code" href="namespacedlib.html#a3d0eb509fdefecd0e9f75bab1a0c97d9">00125</a>     <span class="keyword">enum</span> <a class="code" href="namespacedlib.html#a3d0eb509fdefecd0e9f75bab1a0c97d9">general_return_codes</a>
<a name="l00126"></a>00126     {
<a name="l00127"></a>00127         TIMEOUT     = -1,
<a name="l00128"></a>00128         WOULDBLOCK  = -2,
<a name="l00129"></a>00129         OTHER_ERROR = -3,
<a name="l00130"></a>00130         SHUTDOWN    = -4,
<a name="l00131"></a>00131         PORTINUSE   = -5
<a name="l00132"></a>00132     };
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00135"></a>00135 
<a name="l00136"></a><a class="code" href="namespacedlib.html#aa718d15067f15dd851a98eb1088131ae">00136</a>     <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="namespacedlib.html#aa718d15067f15dd851a98eb1088131ae">square_root</a> (
<a name="l00137"></a>00137         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value
<a name="l00138"></a>00138     )
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> x;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         <span class="comment">// set the initial guess for what the root is depending on </span>
<a name="l00150"></a>00150         <span class="comment">// how big value is</span>
<a name="l00151"></a>00151         <span class="keywordflow">if</span> (value &lt; 3)
<a name="l00152"></a>00152             <span class="keywordflow">return</span> value;
<a name="l00153"></a>00153         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 4096) <span class="comment">// 12</span>
<a name="l00154"></a>00154             x = 45;
<a name="l00155"></a>00155         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 65536) <span class="comment">// 16</span>
<a name="l00156"></a>00156             x = 179;
<a name="l00157"></a>00157         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 1048576) <span class="comment">// 20</span>
<a name="l00158"></a>00158             x = 717;
<a name="l00159"></a>00159         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 16777216) <span class="comment">// 24</span>
<a name="l00160"></a>00160             x = 2867;
<a name="l00161"></a>00161         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 268435456) <span class="comment">// 28</span>
<a name="l00162"></a>00162             x = 11469;
<a name="l00163"></a>00163         <span class="keywordflow">else</span>   <span class="comment">// 32</span>
<a name="l00164"></a>00164             x = 45875;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         <span class="comment">// find the root</span>
<a name="l00169"></a>00169         x = (x + value/x)&gt;&gt;1;
<a name="l00170"></a>00170         x = (x + value/x)&gt;&gt;1;
<a name="l00171"></a>00171         x = (x + value/x)&gt;&gt;1;
<a name="l00172"></a>00172         x = (x + value/x)&gt;&gt;1;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <span class="keywordflow">if</span> (x*x &lt; value)
<a name="l00177"></a>00177             <span class="keywordflow">return</span> x+1;
<a name="l00178"></a>00178         <span class="keywordflow">else</span>
<a name="l00179"></a>00179             <span class="keywordflow">return</span> x;
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <span class="keyword">template</span> &lt;
<a name="l00185"></a>00185         <span class="keyword">typename</span> T
<a name="l00186"></a>00186         &gt;    
<a name="l00187"></a>00187     <span class="keywordtype">void</span> <a class="code" href="namespacedlib.html#af2608709700ae61f169fd4687e406267">median</a> (
<a name="l00188"></a>00188         T&amp; one,
<a name="l00189"></a>00189         T&amp; two,
<a name="l00190"></a>00190         T&amp; three
<a name="l00191"></a>00191     );
<a name="l00202"></a>00202     <span class="keyword">template</span> &lt;
<a name="l00203"></a>00203         <span class="keyword">typename</span> T
<a name="l00204"></a>00204         &gt;
<a name="l00205"></a><a class="code" href="namespacedlib.html#af2608709700ae61f169fd4687e406267">00205</a>     <span class="keywordtype">void</span> <a class="code" href="namespacedlib.html#af2608709700ae61f169fd4687e406267">median</a> (
<a name="l00206"></a>00206         T&amp; one,
<a name="l00207"></a>00207         T&amp; two,
<a name="l00208"></a>00208         T&amp; three
<a name="l00209"></a>00209     )    
<a name="l00210"></a>00210     {    
<a name="l00211"></a>00211         <span class="keyword">using</span> std::swap;
<a name="l00212"></a>00212         <span class="keyword">using</span> dlib::swap;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">if</span> ( one &lt; two )
<a name="l00215"></a>00215         {
<a name="l00216"></a>00216             <span class="comment">// one &lt; two</span>
<a name="l00217"></a>00217             <span class="keywordflow">if</span> ( two &lt; three )
<a name="l00218"></a>00218             {
<a name="l00219"></a>00219                 <span class="comment">// one &lt; two &lt; three : two</span>
<a name="l00220"></a>00220                 swap(one,two);
<a name="l00221"></a>00221                 
<a name="l00222"></a>00222             }
<a name="l00223"></a>00223             <span class="keywordflow">else</span>
<a name="l00224"></a>00224             {
<a name="l00225"></a>00225                 <span class="comment">// one &lt; two &gt;= three</span>
<a name="l00226"></a>00226                 <span class="keywordflow">if</span> ( one &lt; three)
<a name="l00227"></a>00227                 {
<a name="l00228"></a>00228                     <span class="comment">// three</span>
<a name="l00229"></a>00229                     swap(three,one);
<a name="l00230"></a>00230                 }
<a name="l00231"></a>00231             }
<a name="l00232"></a>00232             
<a name="l00233"></a>00233         }
<a name="l00234"></a>00234         <span class="keywordflow">else</span>
<a name="l00235"></a>00235         {
<a name="l00236"></a>00236             <span class="comment">// one &gt;= two</span>
<a name="l00237"></a>00237             <span class="keywordflow">if</span> ( three &lt; one )
<a name="l00238"></a>00238             {
<a name="l00239"></a>00239                 <span class="comment">// three &lt;= one &gt;= two</span>
<a name="l00240"></a>00240                 <span class="keywordflow">if</span> ( three &lt; two )
<a name="l00241"></a>00241                 {
<a name="l00242"></a>00242                     <span class="comment">// two</span>
<a name="l00243"></a>00243                     swap(two,one);
<a name="l00244"></a>00244                 }
<a name="l00245"></a>00245                 <span class="keywordflow">else</span>
<a name="l00246"></a>00246                 {
<a name="l00247"></a>00247                     <span class="comment">// three</span>
<a name="l00248"></a>00248                     swap(three,one);
<a name="l00249"></a>00249                 }
<a name="l00250"></a>00250             }
<a name="l00251"></a>00251         }        
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keyword">namespace </span>relational_operators
<a name="l00257"></a>00257     {
<a name="l00258"></a>00258         <span class="keyword">template</span> &lt;
<a name="l00259"></a>00259             <span class="keyword">typename</span> A,
<a name="l00260"></a>00260             <span class="keyword">typename</span> B
<a name="l00261"></a>00261             &gt;
<a name="l00262"></a>00262         <span class="keywordtype">bool</span> operator&gt; (
<a name="l00263"></a>00263             <span class="keyword">const</span> A&amp; a,
<a name="l00264"></a>00264             <span class="keyword">const</span> B&amp; b
<a name="l00265"></a>00265         ) { <span class="keywordflow">return</span> b &lt; a; }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     <span class="comment">// ---------------------------------</span>
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="keyword">template</span> &lt;
<a name="l00270"></a>00270             <span class="keyword">typename</span> A,
<a name="l00271"></a>00271             <span class="keyword">typename</span> B
<a name="l00272"></a>00272             &gt;
<a name="l00273"></a>00273         <span class="keywordtype">bool</span> operator!= (
<a name="l00274"></a>00274             <span class="keyword">const</span> A&amp; a,
<a name="l00275"></a>00275             <span class="keyword">const</span> B&amp; b
<a name="l00276"></a>00276         ) { <span class="keywordflow">return</span> !(a == b); }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="comment">// ---------------------------------</span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="keyword">template</span> &lt;
<a name="l00281"></a>00281             <span class="keyword">typename</span> A,
<a name="l00282"></a>00282             <span class="keyword">typename</span> B
<a name="l00283"></a>00283             &gt;
<a name="l00284"></a>00284         <span class="keywordtype">bool</span> operator&lt;= (
<a name="l00285"></a>00285             <span class="keyword">const</span> A&amp; a,
<a name="l00286"></a>00286             <span class="keyword">const</span> B&amp; b
<a name="l00287"></a>00287         ) { <span class="keywordflow">return</span> !(b &lt; a); }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="comment">// ---------------------------------</span>
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         <span class="keyword">template</span> &lt;
<a name="l00292"></a>00292             <span class="keyword">typename</span> A,
<a name="l00293"></a>00293             <span class="keyword">typename</span> B
<a name="l00294"></a>00294             &gt;
<a name="l00295"></a>00295         <span class="keywordtype">bool</span> operator&gt;= (
<a name="l00296"></a>00296             <span class="keyword">const</span> A&amp; a,
<a name="l00297"></a>00297             <span class="keyword">const</span> B&amp; b
<a name="l00298"></a>00298         ) { <span class="keywordflow">return</span> !(a &lt; b); }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     <span class="keyword">template</span> &lt;
<a name="l00305"></a>00305         <span class="keyword">typename</span> T
<a name="l00306"></a>00306         &gt;
<a name="l00307"></a><a class="code" href="namespacedlib.html#a7a50a190179be95c0d38aaa92960d1dc">00307</a>     <span class="keywordtype">void</span> <a class="code" href="namespacedlib.html#a7a50a190179be95c0d38aaa92960d1dc">exchange</a> (
<a name="l00308"></a>00308         T&amp; a,
<a name="l00309"></a>00309         T&amp; b
<a name="l00310"></a>00310     )
<a name="l00323"></a>00323     {
<a name="l00324"></a>00324         <span class="keyword">using</span> std::swap;
<a name="l00325"></a>00325         <span class="keyword">using</span> dlib::swap;
<a name="l00326"></a>00326         swap(a,b);
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00330"></a>00330 
<a name="l00337"></a>00337     <span class="keyword">template</span> &lt;
<a name="l00338"></a>00338         <span class="keyword">typename</span> T
<a name="l00339"></a>00339         &gt;
<a name="l00340"></a><a class="code" href="classdlib_1_1is__pointer__type.html">00340</a>     <span class="keyword">class </span><a class="code" href="classdlib_1_1is__pointer__type.html">is_pointer_type</a>
<a name="l00341"></a>00341     {
<a name="l00342"></a>00342     <span class="keyword">public</span>:
<a name="l00343"></a>00343         <span class="keyword">enum</span> { value = <span class="keyword">false</span> };
<a name="l00344"></a>00344     <span class="keyword">private</span>:
<a name="l00345"></a>00345         <a class="code" href="classdlib_1_1is__pointer__type.html">is_pointer_type</a>();
<a name="l00346"></a>00346     };
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="keyword">template</span> &lt;
<a name="l00349"></a>00349         <span class="keyword">typename</span> T
<a name="l00350"></a>00350         &gt;
<a name="l00351"></a><a class="code" href="classdlib_1_1is__pointer__type_3_01T_01_5_01_4.html">00351</a>     <span class="keyword">class </span><a class="code" href="classdlib_1_1is__pointer__type.html">is_pointer_type</a>&lt;T*&gt;
<a name="l00352"></a>00352     {
<a name="l00353"></a>00353     <span class="keyword">public</span>:
<a name="l00354"></a>00354         <span class="keyword">enum</span> { value = <span class="keyword">true</span> };
<a name="l00355"></a>00355     <span class="keyword">private</span>:
<a name="l00356"></a>00356         <a class="code" href="classdlib_1_1is__pointer__type.html">is_pointer_type</a>();
<a name="l00357"></a>00357     };
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00360"></a>00360 
<a name="l00367"></a>00367     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00368"></a><a class="code" href="structdlib_1_1is__const__type.html">00368</a>     <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__const__type.html">is_const_type</a>
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">false</span>;
<a name="l00371"></a>00371     };
<a name="l00372"></a>00372     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00373"></a><a class="code" href="structdlib_1_1is__const__type_3_01const_01T_01_4.html">00373</a>     <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__const__type.html">is_const_type</a>&lt;const T&gt;
<a name="l00374"></a>00374     {
<a name="l00375"></a>00375         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>;
<a name="l00376"></a>00376     };
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00379"></a>00379 
<a name="l00386"></a>00386     <span class="keyword">template</span> &lt;
<a name="l00387"></a>00387         <span class="keyword">typename</span> T,
<a name="l00388"></a>00388         <span class="keyword">typename</span> U
<a name="l00389"></a>00389         &gt;
<a name="l00390"></a><a class="code" href="classdlib_1_1is__same__type.html">00390</a>     <span class="keyword">class </span><a class="code" href="classdlib_1_1is__same__type.html">is_same_type</a>
<a name="l00391"></a>00391     {
<a name="l00392"></a>00392     <span class="keyword">public</span>:
<a name="l00393"></a>00393         <span class="keyword">enum</span> {value = <span class="keyword">false</span>};
<a name="l00394"></a>00394     <span class="keyword">private</span>:
<a name="l00395"></a>00395         <a class="code" href="classdlib_1_1is__same__type.html">is_same_type</a>();
<a name="l00396"></a>00396     };
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00399"></a><a class="code" href="classdlib_1_1is__same__type_3_01T_00_01T_01_4.html">00399</a>     <span class="keyword">class </span><a class="code" href="classdlib_1_1is__same__type.html">is_same_type</a>&lt;T,T&gt;
<a name="l00400"></a>00400     {
<a name="l00401"></a>00401     <span class="keyword">public</span>:
<a name="l00402"></a>00402         <span class="keyword">enum</span> {value = <span class="keyword">true</span>};
<a name="l00403"></a>00403     <span class="keyword">private</span>:
<a name="l00404"></a>00404         <a class="code" href="classdlib_1_1is__same__type.html">is_same_type</a>();
<a name="l00405"></a>00405     };
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00408"></a>00408 
<a name="l00419"></a>00419     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> from, <span class="keyword">typename</span> to&gt;
<a name="l00420"></a><a class="code" href="structdlib_1_1is__convertible.html">00420</a>     <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__convertible.html">is_convertible</a>
<a name="l00421"></a>00421     {
<a name="l00422"></a><a class="code" href="structdlib_1_1is__convertible_1_1yes__type.html">00422</a>         <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__convertible_1_1yes__type.html">yes_type</a> { <span class="keywordtype">char</span> a; };
<a name="l00423"></a><a class="code" href="structdlib_1_1is__convertible_1_1no__type.html">00423</a>         <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__convertible_1_1no__type.html">no_type</a> { <a class="code" href="structdlib_1_1is__convertible_1_1yes__type.html">yes_type</a> a[2]; };
<a name="l00424"></a>00424         <span class="keyword">static</span> <span class="keyword">const</span> from&amp; from_helper();
<a name="l00425"></a>00425         <span class="keyword">static</span> <a class="code" href="structdlib_1_1is__convertible_1_1yes__type.html">yes_type</a> test(to);
<a name="l00426"></a>00426         <span class="keyword">static</span> <a class="code" href="structdlib_1_1is__convertible_1_1no__type.html">no_type</a> test(...);
<a name="l00427"></a>00427         <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">sizeof</span>(test(from_helper())) == <span class="keyword">sizeof</span>(<a class="code" href="structdlib_1_1is__convertible_1_1yes__type.html">yes_type</a>);
<a name="l00428"></a>00428     };
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00431"></a>00431 
<a name="l00437"></a>00437     <span class="keyword">template</span> &lt;
<a name="l00438"></a>00438         <span class="keyword">typename</span> T
<a name="l00439"></a>00439         &gt;
<a name="l00440"></a><a class="code" href="structdlib_1_1is__unsigned__type.html">00440</a>     <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__unsigned__type.html">is_unsigned_type</a>
<a name="l00441"></a>00441     {
<a name="l00442"></a>00442         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>((<span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0)-static_cast&lt;T&gt;(1))) &gt; 0;
<a name="l00443"></a>00443     };
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00446"></a>00446 
<a name="l00452"></a>00452     <span class="keyword">template</span> &lt;
<a name="l00453"></a>00453         <span class="keyword">typename</span> T
<a name="l00454"></a>00454         &gt;
<a name="l00455"></a><a class="code" href="structdlib_1_1is__signed__type.html">00455</a>     <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__signed__type.html">is_signed_type</a>
<a name="l00456"></a>00456     {
<a name="l00457"></a>00457         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = !<a class="code" href="structdlib_1_1is__unsigned__type.html">is_unsigned_type&lt;T&gt;::value</a>;
<a name="l00458"></a>00458     };
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keyword">template</span> &lt;
<a name="l00463"></a>00463         <span class="keyword">typename</span> T
<a name="l00464"></a>00464         &gt;
<a name="l00465"></a><a class="code" href="classdlib_1_1copy__functor.html">00465</a>     <span class="keyword">class </span><a class="code" href="classdlib_1_1copy__functor.html">copy_functor</a>
<a name="l00466"></a>00466     {
<a name="l00467"></a>00467     <span class="keyword">public</span>:
<a name="l00468"></a>00468         <span class="keywordtype">void</span> operator() (
<a name="l00469"></a>00469             <span class="keyword">const</span> T&amp; source, 
<a name="l00470"></a>00470             T&amp; destination
<a name="l00471"></a>00471         )<span class="keyword"> const</span>
<a name="l00472"></a>00472 <span class="keyword">        </span>{
<a name="l00473"></a>00473             destination = source;
<a name="l00474"></a>00474         }
<a name="l00475"></a>00475     };
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00478"></a>00478 
<a name="l00492"></a>00492     <span class="keyword">template</span> &lt; <span class="keywordtype">bool</span> v1 = 0, <span class="keywordtype">bool</span> v2 = 0, <span class="keywordtype">bool</span> v3 = 0, <span class="keywordtype">bool</span> v4 = 0, <span class="keywordtype">bool</span> v5 = 0,
<a name="l00493"></a>00493                <span class="keywordtype">bool</span> v6 = 0, <span class="keywordtype">bool</span> v7 = 0, <span class="keywordtype">bool</span> v8 = 0, <span class="keywordtype">bool</span> v9 = 0, <span class="keywordtype">bool</span> v10 = 0, 
<a name="l00494"></a>00494                <span class="keywordtype">bool</span> v11 = 0, <span class="keywordtype">bool</span> v12 = 0, <span class="keywordtype">bool</span> v13 = 0, <span class="keywordtype">bool</span> v14 = 0, <span class="keywordtype">bool</span> v15 = 0 &gt;
<a name="l00495"></a>00495     <span class="keyword">struct </span>static_switch; 
<a name="l00496"></a>00496 
<a name="l00497"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01297db704ac0ccd7cdf569f49ff1837f4.html">00497</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 0; };
<a name="l00498"></a><a class="code" href="structdlib_1_1static__switch_3_011_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01e6d4ee9dd0db82c25ad3e5e162ffcf57.html">00498</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;1,0,0,0,0,0,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 1; };
<a name="l00499"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_011_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_013c4ac657bc48737c62a5b545ecf666e2.html">00499</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,1,0,0,0,0,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 2; };
<a name="l00500"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_011_00_010_00_010_00_010_00_010_00_010_00_010_00_01f20039fe97478cfcdfb8a6fb10d88c23.html">00500</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,1,0,0,0,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 3; };
<a name="l00501"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_011_00_010_00_010_00_010_00_010_00_010_00_017e7e1ea6f90a3743d68a10bc9ac43767.html">00501</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,1,0,0,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 4; };
<a name="l00502"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_011_00_010_00_010_00_010_00_010_00_01ff4b50cffbfc7efeb2ebcd8ac49664ca.html">00502</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,1,0,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 5; };
<a name="l00503"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_011_00_010_00_010_00_010_00_01065a8f5a38c76e0fbec03f2ecf64307a.html">00503</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,1,0,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 6; };
<a name="l00504"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010_00_010_00_01f96a27221d42a17b5e8ff3b09c0ae4ae.html">00504</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,1,0,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 7; };
<a name="l00505"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010_00_0105236f4c56e9666de491dbb566b29360.html">00505</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,1,0,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 8; };
<a name="l00506"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010dd8c605dbfd043e236f91723a992215.html">00506</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,1,0,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 9; };
<a name="l00507"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011e8c10a795cabaf3f5d590d7d2ed509c.html">00507</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,1,0,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 10; };
<a name="l00508"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0145cbcc58af0c0409c47cc48fc11394ec.html">00508</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,0,1,0,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 11; };
<a name="l00509"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0147e6a475a446e40bfc581407a8174f9f.html">00509</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,0,0,1,0,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 12; };
<a name="l00510"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01de46d05550779d2bbe7720ab7bfdb3cc.html">00510</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,0,0,0,1,0,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 13; };
<a name="l00511"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_016cef4822784544663fb033f63ec96728.html">00511</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,0,0,0,0,1,0&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 14; };
<a name="l00512"></a><a class="code" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0146ef5bf350d722d5ffb766430493f3da.html">00512</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>static_switch&lt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,1&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> value = 15; };
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00524"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">00524</a> <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>        { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">false</span>; };
<a name="l00525"></a>00525 
<a name="l00526"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01float_01_4.html">00526</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;float&gt;           { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00527"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01double_01_4.html">00527</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;double&gt;          { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00528"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01long_01double_01_4.html">00528</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;long double&gt;     { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00529"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01short_01_4.html">00529</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;short&gt;           { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00530"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01int_01_4.html">00530</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;int&gt;             { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00531"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01long_01_4.html">00531</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;long&gt;            { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00532"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01short_01_4.html">00532</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;unsigned short&gt;  { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00533"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01int_01_4.html">00533</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;unsigned int&gt;    { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00534"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01long_01_4.html">00534</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;unsigned long&gt;   { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00535"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01uint64_01_4.html">00535</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;<a class="code" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">uint64</a>&gt;          { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00536"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01char_01_4.html">00536</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;char&gt;            { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00537"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01signed_01char_01_4.html">00537</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;signed char&gt;     { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00538"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01char_01_4.html">00538</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;unsigned char&gt;   { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00539"></a>00539     <span class="comment">// Don&apos;t define one for wchar_t when using a version of visual studio</span>
<a name="l00540"></a>00540     <span class="comment">// older than 8.0 (visual studio 2005) since before then they improperly set</span>
<a name="l00541"></a>00541     <span class="comment">// wchar_t to be a typedef rather than its own type as required by the C++ </span>
<a name="l00542"></a>00542     <span class="comment">// standard.</span>
<a name="l00543"></a>00543 <span class="preprocessor">#if !defined(_MSC_VER) || _NATIVE_WCHAR_T_DEFINED</span>
<a name="l00544"></a><a class="code" href="structdlib_1_1is__built__in__scalar__type_3_01wchar__t_01_4.html">00544</a> <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt;wchar_t&gt;         { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00545"></a>00545 <span class="preprocessor">#endif</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span>
<a name="l00547"></a>00547 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00548"></a>00548     
<a name="l00556"></a>00556     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1disable__if.html">disable_if&lt;is_built_in_scalar_type&lt;T&gt;</a>,<span class="keywordtype">void</span>&gt;::type <a class="code" href="namespacedlib.html#ab31aceb3894feb837313ad0add9d9294">assign_zero_if_built_in_scalar_type</a> (T&amp;){}
<a name="l00557"></a><a class="code" href="namespacedlib.html#ab31aceb3894feb837313ad0add9d9294">00557</a>     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1enable__if.html">enable_if&lt;is_built_in_scalar_type&lt;T&gt;</a>,<span class="keywordtype">void</span>&gt;::type <a class="code" href="namespacedlib.html#ab31aceb3894feb837313ad0add9d9294">assign_zero_if_built_in_scalar_type</a> (T&amp; a){a=0;}
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00562"></a><a class="code" href="namespacedlib.html#a36bcf970b14e81d1c300283a52d64142">00562</a>     T <a class="code" href="namespacedlib.html#a36bcf970b14e81d1c300283a52d64142">put_in_range</a> (
<a name="l00563"></a>00563         <span class="keyword">const</span> T&amp; a, 
<a name="l00564"></a>00564         <span class="keyword">const</span> T&amp; b, 
<a name="l00565"></a>00565         <span class="keyword">const</span> T&amp; val
<a name="l00566"></a>00566     )
<a name="l00576"></a>00576     {
<a name="l00577"></a>00577         <span class="keywordflow">if</span> (a &lt; b)
<a name="l00578"></a>00578         {
<a name="l00579"></a>00579             <span class="keywordflow">if</span> (val &lt; a)
<a name="l00580"></a>00580                 <span class="keywordflow">return</span> a;
<a name="l00581"></a>00581             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &gt; b)
<a name="l00582"></a>00582                 <span class="keywordflow">return</span> b;
<a name="l00583"></a>00583         }
<a name="l00584"></a>00584         <span class="keywordflow">else</span>
<a name="l00585"></a>00585         {
<a name="l00586"></a>00586             <span class="keywordflow">if</span> (val &lt; b)
<a name="l00587"></a>00587                 <span class="keywordflow">return</span> b;
<a name="l00588"></a>00588             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &gt; a)
<a name="l00589"></a>00589                 <span class="keywordflow">return</span> a;
<a name="l00590"></a>00590         }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <span class="keywordflow">return</span> val;
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595     <span class="comment">// overload for double </span>
<a name="l00596"></a>00596     <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="namespacedlib.html#a36bcf970b14e81d1c300283a52d64142">put_in_range</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; b, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; val)
<a name="l00597"></a>00597     { <span class="keywordflow">return</span> put_in_range&lt;double&gt;(a,b,val); }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00600"></a>00600 
<a name="l00610"></a>00610         <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> x, <span class="keyword">typename</span> enabled=<span class="keywordtype">void</span>&gt;
<a name="l00611"></a><a class="code" href="structdlib_1_1tabs.html">00611</a>         <span class="keyword">struct </span><a class="code" href="structdlib_1_1tabs.html">tabs</a> { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">long</span> value = x; };
<a name="l00612"></a>00612         <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> x&gt;
<a name="l00613"></a><a class="code" href="structdlib_1_1tabs_3_01x_00_01typename_01enable__if__c_3_07x_3_010_08_4_1_1type_01_4_02const_01s5583e8a7aa9817e380d6b80c74f287b0.html">00613</a>         <span class="keyword">struct </span><a class="code" href="structdlib_1_1tabs.html">tabs</a>&lt;x,typename <a class="code" href="structboost_1_1enable__if__c.html">enable_if_c</a>&lt;(x &lt; 0)&gt;::type&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">long</span> value = -x; };
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00616"></a>00616 
<a name="l00625"></a>00625         <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> x, <span class="keywordtype">long</span> y, <span class="keyword">typename</span> enabled=<span class="keywordtype">void</span>&gt;
<a name="l00626"></a>00626         <span class="keyword">struct </span>tmax { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">long</span> value = x; };
<a name="l00627"></a>00627         <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> x, <span class="keywordtype">long</span> y&gt;
<a name="l00628"></a>00628         <span class="keyword">struct </span>tmax&lt;x,y,typename enable_if_c&lt;(y &gt; x)&gt;::type&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">long</span> value = y; };
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00631"></a>00631 
<a name="l00640"></a>00640         <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> x, <span class="keywordtype">long</span> y, <span class="keyword">typename</span> enabled=<span class="keywordtype">void</span>&gt;
<a name="l00641"></a><a class="code" href="structdlib_1_1tmin.html">00641</a>         <span class="keyword">struct </span><a class="code" href="structdlib_1_1tmin.html">tmin</a> { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">long</span> value = x; };
<a name="l00642"></a>00642         <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> x, <span class="keywordtype">long</span> y&gt;
<a name="l00643"></a>00643         <span class="keyword">struct </span><a class="code" href="structdlib_1_1tmin.html">tmin</a>&lt;x,y,typename <a class="code" href="structboost_1_1enable__if__c.html">enable_if_c</a>&lt;(y &lt; x)&gt;::type&gt; { <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">long</span> value = y; };
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00646"></a>00646 
<a name="l00658"></a>00658     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>is_function { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">false</span>; };
<a name="l00659"></a>00659     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 
<a name="l00660"></a>00660     <span class="keyword">struct </span>is_function&lt;T (void)&gt; { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00661"></a>00661     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0&gt; 
<a name="l00662"></a>00662     <span class="keyword">struct </span>is_function&lt;T (A0)&gt; { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00663"></a>00663     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1&gt; 
<a name="l00664"></a>00664     <span class="keyword">struct </span>is_function&lt;T (A0, A1)&gt; { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00665"></a>00665     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt; 
<a name="l00666"></a>00666     <span class="keyword">struct </span>is_function&lt;T (A0, A1, A2)&gt; { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00667"></a>00667     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> A3&gt; 
<a name="l00668"></a>00668     <span class="keyword">struct </span>is_function&lt;T (A0, A1, A2, A3)&gt; { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00669"></a>00669     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> A3, <span class="keyword">typename</span> A4&gt; 
<a name="l00670"></a>00670     <span class="keyword">struct </span>is_function&lt;T (A0, A1, A2, A3, A4)&gt; { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>; };
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>funct_wrap0
<a name="l00674"></a>00674     {
<a name="l00675"></a>00675     <span class="keyword">public</span>:
<a name="l00676"></a>00676         funct_wrap0(T (&amp;f_)()):f(f_){}
<a name="l00677"></a>00677         T operator()()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f(); }
<a name="l00678"></a>00678     <span class="keyword">private</span>:
<a name="l00679"></a>00679         T (&amp;f)();
<a name="l00680"></a>00680     };
<a name="l00681"></a>00681     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0&gt; <span class="keyword">class </span>funct_wrap1
<a name="l00682"></a>00682     {
<a name="l00683"></a>00683     <span class="keyword">public</span>:
<a name="l00684"></a>00684         funct_wrap1(T (&amp;f_)(A0)):f(f_){}
<a name="l00685"></a>00685         T operator()(A0 a0)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f(a0); }
<a name="l00686"></a>00686     <span class="keyword">private</span>:
<a name="l00687"></a>00687         T (&amp;f)(A0);
<a name="l00688"></a>00688     };
<a name="l00689"></a>00689     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1&gt; <span class="keyword">class </span>funct_wrap2
<a name="l00690"></a>00690     {
<a name="l00691"></a>00691     <span class="keyword">public</span>:
<a name="l00692"></a>00692         funct_wrap2(T (&amp;f_)(A0,A1)):f(f_){}
<a name="l00693"></a>00693         T operator()(A0 a0, A1 a1)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f(a0,a1); }
<a name="l00694"></a>00694     <span class="keyword">private</span>:
<a name="l00695"></a>00695         T (&amp;f)(A0,A1);
<a name="l00696"></a>00696     };
<a name="l00697"></a>00697     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt; <span class="keyword">class </span>funct_wrap3
<a name="l00698"></a>00698     {
<a name="l00699"></a>00699     <span class="keyword">public</span>:
<a name="l00700"></a>00700         funct_wrap3(T (&amp;f_)(A0,A1,A2)):f(f_){}
<a name="l00701"></a>00701         T operator()(A0 a0, A1 a1, A2 a2)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f(a0,a1,a2); }
<a name="l00702"></a>00702     <span class="keyword">private</span>:
<a name="l00703"></a>00703         T (&amp;f)(A0,A1,A2);
<a name="l00704"></a>00704     };
<a name="l00705"></a>00705     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> A3&gt; <span class="keyword">class </span>funct_wrap4
<a name="l00706"></a>00706     {
<a name="l00707"></a>00707     <span class="keyword">public</span>:
<a name="l00708"></a>00708         funct_wrap4(T (&amp;f_)(A0,A1,A2,A3)):f(f_){}
<a name="l00709"></a>00709         T operator()(A0 a0, A1 a1, A2 a2, A3 a3)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f(a0,a1,a2,a3); }
<a name="l00710"></a>00710     <span class="keyword">private</span>:
<a name="l00711"></a>00711         T (&amp;f)(A0,A1,A2,A3);
<a name="l00712"></a>00712     };
<a name="l00713"></a>00713     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> A3, <span class="keyword">typename</span> A4&gt; <span class="keyword">class </span>funct_wrap5
<a name="l00714"></a>00714     {
<a name="l00715"></a>00715     <span class="keyword">public</span>:
<a name="l00716"></a>00716         funct_wrap5(T (&amp;f_)(A0,A1,A2,A3,A4)):f(f_){}
<a name="l00717"></a>00717         T operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f(a0,a1,a2,a3,a4); }
<a name="l00718"></a>00718     <span class="keyword">private</span>:
<a name="l00719"></a>00719         T (&amp;f)(A0,A1,A2,A3,A4);
<a name="l00720"></a>00720     };
<a name="l00721"></a>00721 
<a name="l00743"></a>00743     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00744"></a>00744     funct_wrap0&lt;T&gt; wrap_function(T (&amp;f)()) { <span class="keywordflow">return</span> funct_wrap0&lt;T&gt;(f); }
<a name="l00745"></a>00745     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0&gt;
<a name="l00746"></a>00746     funct_wrap1&lt;T,A0&gt; wrap_function(T (&amp;f)(A0)) { <span class="keywordflow">return</span> funct_wrap1&lt;T,A0&gt;(f); }
<a name="l00747"></a>00747     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1&gt;
<a name="l00748"></a>00748     funct_wrap2&lt;T,A0,A1&gt; wrap_function(T (&amp;f)(A0, A1)) { <span class="keywordflow">return</span> funct_wrap2&lt;T,A0,A1&gt;(f); }
<a name="l00749"></a>00749     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
<a name="l00750"></a>00750     funct_wrap3&lt;T,A0,A1,A2&gt; wrap_function(T (&amp;f)(A0, A1, A2)) { <span class="keywordflow">return</span> funct_wrap3&lt;T,A0,A1,A2&gt;(f); }
<a name="l00751"></a>00751     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> A3&gt;
<a name="l00752"></a>00752     funct_wrap4&lt;T,A0,A1,A2,A3&gt; wrap_function(T (&amp;f)(A0, A1, A2, A3)) { <span class="keywordflow">return</span> funct_wrap4&lt;T,A0,A1,A2,A3&gt;(f); }
<a name="l00753"></a>00753     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A0, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> A3, <span class="keyword">typename</span> A4&gt;
<a name="l00754"></a>00754     funct_wrap5&lt;T,A0,A1,A2,A3,A4&gt; wrap_function(T (&amp;f)(A0, A1, A2, A3, A4)) { <span class="keywordflow">return</span> funct_wrap5&lt;T,A0,A1,A2,A3,A4&gt;(f); }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00757"></a>00757 
<a name="l00758"></a>00758     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bSIZE&gt;
<a name="l00759"></a>00759     <span class="keyword">class </span>stack_based_memory_block : noncopyable
<a name="l00760"></a>00760     {
<a name="l00767"></a>00767     <span class="keyword">public</span>:
<a name="l00768"></a>00768         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size = bSIZE;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770         stack_based_memory_block(): data(mem.data) {}
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         <span class="keywordtype">void</span>* <span class="keyword">get</span> () { <span class="keywordflow">return</span> data; }
<a name="l00778"></a>00778         <span class="keyword">const</span> <span class="keywordtype">void</span>* <span class="keyword">get</span> () <span class="keyword">const</span> { <span class="keywordflow">return</span> data; }
<a name="l00784"></a>00784     <span class="keyword">private</span>:
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="comment">// You obviously can&apos;t have a block of memory that has zero bytes in it.</span>
<a name="l00787"></a>00787         COMPILE_TIME_ASSERT(bSIZE &gt; 0);
<a name="l00788"></a>00788         
<a name="l00789"></a><a class="code" href="uniondlib_1_1mem__block.html">00789</a>         <span class="keyword">union </span><a class="code" href="uniondlib_1_1mem__block.html">mem_block</a>
<a name="l00790"></a>00790         {
<a name="l00791"></a>00791             <span class="comment">// All of this garbage is to make sure this union is properly aligned </span>
<a name="l00792"></a>00792             <span class="comment">// (a union is always aligned such that everything in it would be properly</span>
<a name="l00793"></a>00793             <span class="comment">// aligned.  So the assumption here is that one of these objects has </span>
<a name="l00794"></a>00794             <span class="comment">// a large enough alignment requirement to satisfy any object this</span>
<a name="l00795"></a>00795             <span class="comment">// block of memory might be cast into).</span>
<a name="l00796"></a>00796             <span class="keywordtype">void</span>* void_ptr;
<a name="l00797"></a>00797             <span class="keywordtype">int</span> integer;
<a name="l00798"></a>00798             <span class="keyword">struct </span>{
<a name="l00799"></a>00799                 void (stack_based_memory_block::*callback)();
<a name="l00800"></a>00800                 stack_based_memory_block* o; 
<a name="l00801"></a>00801             } stuff;
<a name="l00802"></a>00802             <span class="keywordtype">long</span> <span class="keywordtype">double</span> more_stuff;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804             <a class="code" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">uint64</a> var1;
<a name="l00805"></a>00805             uint32 var2;
<a name="l00806"></a>00806             <span class="keywordtype">double</span> var3;
<a name="l00807"></a>00807 
<a name="l00808"></a>00808             <span class="keywordtype">char</span> data[size]; 
<a name="l00809"></a>00809         } mem;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         <span class="comment">// The reason for having this variable is that doing it this way avoids</span>
<a name="l00812"></a>00812         <span class="comment">// warnings from gcc about violations of strict-aliasing rules.</span>
<a name="l00813"></a>00813         <span class="keywordtype">void</span>* <span class="keyword">const</span> data; 
<a name="l00814"></a>00814     };
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="comment">// ----------------------------------------------------------------------------------------</span>
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="preprocessor">#endif // DLIB_ALGs_</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Feb 17 11:58:03 2010 for Procedural Game Plot Generation Prototype by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
