<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Procedural Game Plot Generation Prototype: dlib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dlib Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib_1_1sort__helpers.html">sort_helpers</a></td></tr>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1is__pointer__type.html">is_pointer_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1is__pointer__type_3_01T_01_5_01_4.html">is_pointer_type&lt; T * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__const__type.html">is_const_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__const__type_3_01const_01T_01_4.html">is_const_type&lt; const T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1is__same__type.html">is_same_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1is__same__type_3_01T_00_01T_01_4.html">is_same_type&lt; T, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__convertible.html">is_convertible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__unsigned__type.html">is_unsigned_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__signed__type.html">is_signed_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1copy__functor.html">copy_functor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01297db704ac0ccd7cdf569f49ff1837f4.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_011_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01e6d4ee9dd0db82c25ad3e5e162ffcf57.html">static_switch&lt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_011_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_013c4ac657bc48737c62a5b545ecf666e2.html">static_switch&lt; 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_011_00_010_00_010_00_010_00_010_00_010_00_010_00_01f20039fe97478cfcdfb8a6fb10d88c23.html">static_switch&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_011_00_010_00_010_00_010_00_010_00_010_00_017e7e1ea6f90a3743d68a10bc9ac43767.html">static_switch&lt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_011_00_010_00_010_00_010_00_010_00_01ff4b50cffbfc7efeb2ebcd8ac49664ca.html">static_switch&lt; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_011_00_010_00_010_00_010_00_01065a8f5a38c76e0fbec03f2ecf64307a.html">static_switch&lt; 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010_00_010_00_01f96a27221d42a17b5e8ff3b09c0ae4ae.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010_00_0105236f4c56e9666de491dbb566b29360.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010dd8c605dbfd043e236f91723a992215.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011e8c10a795cabaf3f5d590d7d2ed509c.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0145cbcc58af0c0409c47cc48fc11394ec.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0147e6a475a446e40bfc581407a8174f9f.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01de46d05550779d2bbe7720ab7bfdb3cc.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_016cef4822784544663fb033f63ec96728.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0146ef5bf350d722d5ffb766430493f3da.html">static_switch&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01float_01_4.html">is_built_in_scalar_type&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01double_01_4.html">is_built_in_scalar_type&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01long_01double_01_4.html">is_built_in_scalar_type&lt; long double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01short_01_4.html">is_built_in_scalar_type&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01int_01_4.html">is_built_in_scalar_type&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01long_01_4.html">is_built_in_scalar_type&lt; long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01short_01_4.html">is_built_in_scalar_type&lt; unsigned short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01int_01_4.html">is_built_in_scalar_type&lt; unsigned int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01long_01_4.html">is_built_in_scalar_type&lt; unsigned long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01uint64_01_4.html">is_built_in_scalar_type&lt; uint64 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01char_01_4.html">is_built_in_scalar_type&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01signed_01char_01_4.html">is_built_in_scalar_type&lt; signed char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01unsigned_01char_01_4.html">is_built_in_scalar_type&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__built__in__scalar__type_3_01wchar__t_01_4.html">is_built_in_scalar_type&lt; wchar_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1tabs.html">tabs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1tabs_3_01x_00_01typename_01enable__if__c_3_07x_3_010_08_4_1_1type_01_4_02const_01s5583e8a7aa9817e380d6b80c74f287b0.html">tabs&lt; x, typename enable_if_c&lt;(x&lt; 0)&gt;::type &gt;{const static long value=-x;};template&lt; long x, long y, typename enabled=void &gt;struct tmax{const static long value=x;};template&lt; long x, long y &gt;struct tmax&lt; x, y, typename enable_if_c&lt;(y &gt; x)&gt;::type &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1tmin.html">tmin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniondlib_1_1mem__block.html">mem_block</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1array.html">array</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1array2d.html">array2d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1compile__time__assert_3_01true_01_4.html">compile_time_assert&lt; true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1assert__are__same__type_3_01T_00_01T_01_4.html">assert_are_same_type&lt; T, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1assert__are__not__same__type.html">assert_are_not_same_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1assert__are__not__same__type_3_01T_00_01T_01_4.html">assert_are_not_same_type&lt; T, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1base64.html">base64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1assignment.html">assignment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1joint__probability__table.html">joint_probability_table</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1conditional__probability__table.html">conditional_probability_table</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1bayes__node.html">bayes_node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1bayesian__network__gibbs__sampler.html">bayesian_network_gibbs_sampler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1bayesian__network__join__tree.html">bayesian_network_join_tree</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1bigint.html">bigint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1binary__search__tree.html">binary_search_tree</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1bit__stream.html">bit_stream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1bound__function__pointer.html">bound_function_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1byte__orderer.html">byte_orderer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1cmd__line__parser.html">cmd_line_parser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1compress__stream.html">compress_stream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1conditioning__class.html">conditioning_class</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1config__reader.html">config_reader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1cpp__pretty__printer.html">cpp_pretty_printer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1cpp__tokenizer.html">cpp_tokenizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1crc32.html">crc32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1directed__graph.html">directed_graph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1entropy__decoder.html">entropy_decoder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1entropy__decoder__model.html">entropy_decoder_model</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1entropy__encoder.html">entropy_encoder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1entropy__encoder__model.html">entropy_encoder_model</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1error.html">error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1fatal__error.html">fatal_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1gui__error.html">gui_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1socket__error.html">socket_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1thread__error.html">thread_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1graph.html">graph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1hash__map.html">hash_map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1hash__set.html">hash_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1hash__table.html">hash_table</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1default__is__kind__value.html">default_is_kind_value</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__graph.html">is_graph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__directed__graph.html">is_directed_graph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__matrix.html">is_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__rand.html">is_rand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__std__vector_3_01std_1_1vector_3_01T_00_01alloc_01_4_01_4.html">is_std_vector&lt; std::vector&lt; T, alloc &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__std__vector_3_01T_01_6_01_4.html">is_std_vector&lt; T &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__std__vector_3_01const_01T_01_6_01_4.html">is_std_vector&lt; const T &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1is__std__vector_3_01const_01T_01_4.html">is_std_vector&lt; const T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1linker.html">linker</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1lz77__buffer.html">lz77_buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1lzp__buffer.html">lzp_buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1map.html">map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1member__function__pointer.html">member_function_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1memory__manager.html">memory_manager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1memory__manager__global.html">memory_manager_global</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1memory__manager__stateless.html">memory_manager_stateless</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1mlp.html">mlp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1pipe.html">pipe</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1rgb__pixel.html">rgb_pixel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1bgr__pixel.html">bgr_pixel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1rgb__alpha__pixel.html">rgb_alpha_pixel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1hsi__pixel.html">hsi_pixel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01rgb__pixel_01_4.html">pixel_traits&lt; rgb_pixel &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01bgr__pixel_01_4.html">pixel_traits&lt; bgr_pixel &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01rgb__alpha__pixel_01_4.html">pixel_traits&lt; rgb_alpha_pixel &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01hsi__pixel_01_4.html">pixel_traits&lt; hsi_pixel &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1grayscale__pixel__traits.html">grayscale_pixel_traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01unsigned_01char_01_4.html">pixel_traits&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01unsigned_01short_01_4.html">pixel_traits&lt; unsigned short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01unsigned_01int_01_4.html">pixel_traits&lt; unsigned int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1pixel__traits_3_01unsigned_01long_01_4.html">pixel_traits&lt; unsigned long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1queue.html">queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1rand.html">rand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1reference__counter.html">reference_counter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1sequence.html">sequence</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1serialization__error.html">serialization_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1server.html">server</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1set.html">set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1sliding__buffer.html">sliding_buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1sockstreambuf.html">sockstreambuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1stack.html">stack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1static__map.html">static_map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1static__set.html">static_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1std__allocator_3_01void_00_01M_01_4.html">std_allocator&lt; void, M &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1std__alloc__compare.html">std_alloc_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1std__alloc__compare_3_01M1_00_01M2_00_01typename_01enable__if_3_01is__same__type_3982ed367adf685c0833f1e72cac3711f.html">std_alloc_compare&lt; M1, M2, typename enable_if&lt; is_same_type&lt; typename M1::mm_global_type, typename M2::mm_global_type &gt; &gt;::type &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1std__alloc__compare_3_01M_00_01M_00_01typename_01enable__if__c_3_01M_1_1is__stateless_01_4_1_1type_01_4.html">std_alloc_compare&lt; M, M, typename enable_if_c&lt; M::is_stateless &gt;::type &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1sync__extension.html">sync_extension</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1timeout.html">timeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1timer.html">timer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1tokenizer.html">tokenizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1unsigned__type_3_01T_00_011_01_4.html">unsigned_type&lt; T, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1unsigned__type_3_01T_00_012_01_4.html">unsigned_type&lt; T, 2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1unsigned__type_3_01T_00_014_01_4.html">unsigned_type&lt; T, 4 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlib_1_1unsigned__type_3_01T_00_018_01_4.html">unsigned_type&lt; T, 8 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdlib_1_1xml__parser.html">xml_parser</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">uint64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8abf353ac58a13a17a60949929cc8a49"></a><!-- doxytag: member="dlib::int64" ref="a8abf353ac58a13a17a60949929cc8a49" args="" -->
typedef long long&nbsp;</td><td class="memItemRight" valign="bottom"><b>int64</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a609c073ecd62413ae2c606909abf62be"></a><!-- doxytag: member="dlib::uint16" ref="a609c073ecd62413ae2c606909abf62be" args="" -->
typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint16</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9279fbd8989417f50695da06d93a7907"></a><!-- doxytag: member="dlib::uint32" ref="a9279fbd8989417f50695da06d93a7907" args="" -->
typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14f6e530a2dc0eceb5c7a0bd824c397c"></a><!-- doxytag: member="dlib::uint8" ref="a14f6e530a2dc0eceb5c7a0bd824c397c" args="" -->
typedef unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint8</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e2c448ebe0af3cab8fa8d405eb7da4d"></a><!-- doxytag: member="dlib::int16" ref="a0e2c448ebe0af3cab8fa8d405eb7da4d" args="" -->
typedef short&nbsp;</td><td class="memItemRight" valign="bottom"><b>int16</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65caa9f663f1fc46f3e05469e564b130"></a><!-- doxytag: member="dlib::int32" ref="a65caa9f663f1fc46f3e05469e564b130" args="" -->
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><b>int32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61ac357a576a46e2de10f08ce050e3b3"></a><!-- doxytag: member="dlib::int8" ref="a61ac357a576a46e2de10f08ce050e3b3" args="" -->
typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><b>int8</b></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a3d0eb509fdefecd0e9f75bab1a0c97d9">general_return_codes</a> { <br/>
&nbsp;&nbsp;<b>TIMEOUT</b> =  -1, 
<b>WOULDBLOCK</b> =  -2, 
<b>OTHER_ERROR</b> =  -3, 
<b>SHUTDOWN</b> =  -4, 
<br/>
&nbsp;&nbsp;<b>PORTINUSE</b> =  -5
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>error_type</b> { <br/>
&nbsp;&nbsp;<b>EOTHER</b>, 
<b>EPORT_IN_USE</b>, 
<b>ETIMEOUT</b>, 
<b>ECONNECTION</b>, 
<br/>
&nbsp;&nbsp;<b>ELISTENER</b>, 
<b>ERESOLVE</b>, 
<b>EMONITOR</b>, 
<b>ECREATE_THREAD</b>, 
<br/>
&nbsp;&nbsp;<b>ECREATE_MUTEX</b>, 
<b>ECREATE_SIGNALER</b>, 
<b>EUNSPECIFIED</b>, 
<b>EGENERAL_TYPE1</b>, 
<br/>
&nbsp;&nbsp;<b>EGENERAL_TYPE2</b>, 
<b>EGENERAL_TYPE3</b>, 
<b>EINVALID_OPTION</b>, 
<b>ETOO_FEW_ARGS</b>, 
<br/>
&nbsp;&nbsp;<b>ETOO_MANY_ARGS</b>, 
<b>ESOCKET</b>, 
<b>ETHREAD</b>, 
<b>EGUI</b>, 
<br/>
&nbsp;&nbsp;<b>EFATAL</b>, 
<b>EBROKEN_ASSERT</b>, 
<b>EIMAGE_LOAD</b>, 
<b>EDIR_CREATE</b>, 
<br/>
&nbsp;&nbsp;<b>EINCOMPATIBLE_OPTIONS</b>, 
<b>EMISSING_REQUIRED_OPTION</b>, 
<b>EINVALID_OPTION_ARG</b>, 
<b>EMULTIPLE_OCCURANCES</b>, 
<br/>
&nbsp;&nbsp;<b>ECONFIG_READER</b>, 
<b>EIMAGE_SAVE</b>, 
<b>ECAST_TO_STRING</b>, 
<b>ESTRING_CAST</b>, 
<br/>
&nbsp;&nbsp;<b>EUTF8_TO_UTF32</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#aa718d15067f15dd851a98eb1088131ae">square_root</a> (unsigned long value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#af2608709700ae61f169fd4687e406267">median</a> (T &amp;one, T &amp;two, T &amp;three)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a7a50a190179be95c0d38aaa92960d1dc">exchange</a> (T &amp;a, T &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1disable__if.html">disable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt; T &gt;<br class="typebreak"/>
, void &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#ab31aceb3894feb837313ad0add9d9294">assign_zero_if_built_in_scalar_type</a> (T &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a36bcf970b14e81d1c300283a52d64142">put_in_range</a> (const T &amp;a, const T &amp;b, const T &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34199fb0e81115d1a7eec041d0f2edef"></a><!-- doxytag: member="dlib::put_in_range" ref="a34199fb0e81115d1a7eec041d0f2edef" args="(const double &amp;a, const double &amp;b, const double &amp;val)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>put_in_range</b> (const double &amp;a, const double &amp;b, const double &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a664fced8a504dcda3711a21258481150"></a><!-- doxytag: member="dlib::operator&lt;&lt;" ref="a664fced8a504dcda3711a21258481150" args="(std::ostream &amp;out, const assignment &amp;a)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classdlib_1_1assignment.html">assignment</a> &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7afaf7852d23c95c6145909611737d13"></a><!-- doxytag: member="dlib::swap" ref="a7afaf7852d23c95c6145909611737d13" args="(assignment &amp;a, assignment &amp;b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdlib_1_1assignment.html">assignment</a> &amp;a, <a class="el" href="classdlib_1_1assignment.html">assignment</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af347d1e8f9880bb7f1f1c3a42ea60df3"></a><!-- doxytag: member="dlib::swap" ref="af347d1e8f9880bb7f1f1c3a42ea60df3" args="(joint_probability_table &amp;a, joint_probability_table &amp;b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdlib_1_1joint__probability__table.html">joint_probability_table</a> &amp;a, <a class="el" href="classdlib_1_1joint__probability__table.html">joint_probability_table</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b27c914488b4014e5719374d7318d9f"></a><!-- doxytag: member="dlib::swap" ref="a8b27c914488b4014e5719374d7318d9f" args="(conditional_probability_table &amp;a, conditional_probability_table &amp;b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdlib_1_1conditional__probability__table.html">conditional_probability_table</a> &amp;a, <a class="el" href="classdlib_1_1conditional__probability__table.html">conditional_probability_table</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bcc46f1847648e253d66802ef05272f"></a><!-- doxytag: member="dlib::swap" ref="a7bcc46f1847648e253d66802ef05272f" args="(bayes_node &amp;a, bayes_node &amp;b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdlib_1_1bayes__node.html">bayes_node</a> &amp;a, <a class="el" href="classdlib_1_1bayes__node.html">bayes_node</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61b07f424fd7415b61689a8fbdda9857"></a><!-- doxytag: member="dlib::swap" ref="a61b07f424fd7415b61689a8fbdda9857" args="(bayesian_network_join_tree &amp;a, bayesian_network_join_tree &amp;b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdlib_1_1bayesian__network__join__tree.html">bayesian_network_join_tree</a> &amp;a, <a class="el" href="classdlib_1_1bayesian__network__join__tree.html">bayesian_network_join_tree</a> &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d76ef041038ff39aa6660f4764ea60d"></a><!-- doxytag: member="dlib::assign_pixel" ref="a8d76ef041038ff39aa6660f4764ea60d" args="(P1 &amp;dest, const P2 &amp;src)" -->
template&lt;typename P1 , typename P2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>assign_pixel</b> (P1 &amp;dest, const P2 &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a88c00fa9d7ea718f6198c72451378f2a">assign_pixel</a> (P &amp;dest, const int src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a5756e98c19859a24eb42d6b906808095">assign_pixel</a> (P &amp;dest, const long src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#acadbad5cd1cbaf9f188eb56b518a0f01">get_pixel_intensity</a> (const P &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a3b9a3281788e2c68adbe5e81265aaeb2">assign_pixel_intensity</a> (P &amp;dest, const unsigned long new_intensity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#ac78b72e65600a0d25ac3224539794fc2">serialize</a> (const <a class="el" href="structdlib_1_1rgb__pixel.html">rgb_pixel</a> &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a5e5ead1e1179ca255a628e46a55d12ce">deserialize</a> (<a class="el" href="structdlib_1_1rgb__pixel.html">rgb_pixel</a> &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#aefd5ce982b258dc62d2c4a657278a492">serialize</a> (const <a class="el" href="structdlib_1_1bgr__pixel.html">bgr_pixel</a> &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a2ffefe1102a7c709e26a23b4f2c7668c">deserialize</a> (<a class="el" href="structdlib_1_1bgr__pixel.html">bgr_pixel</a> &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#abbbd5224f9387eef940579cdf3fd4a13">serialize</a> (const <a class="el" href="structdlib_1_1rgb__alpha__pixel.html">rgb_alpha_pixel</a> &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a59df13454703d695429ac5af04c8cb35">deserialize</a> (<a class="el" href="structdlib_1_1rgb__alpha__pixel.html">rgb_alpha_pixel</a> &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#add718e65e3023a2abd8eb04200e81b52">serialize</a> (const <a class="el" href="structdlib_1_1hsi__pixel.html">hsi_pixel</a> &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a5291c6d8fcf1bd624eaa7f908ea137bf">deserialize</a> (<a class="el" href="structdlib_1_1hsi__pixel.html">hsi_pixel</a> &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a21491eceab973e1bd6efb6730dfdc890"></a><!-- doxytag: member="dlib::assign_pixel" ref="a21491eceab973e1bd6efb6730dfdc890" args="(P1 &amp;dest, const int src)" -->
template&lt;typename P1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>assign_pixel</b> (P1 &amp;dest, const int src)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f5a56be49a2fdda3449976b8234ec72"></a><!-- doxytag: member="dlib::assign_pixel" ref="a5f5a56be49a2fdda3449976b8234ec72" args="(P1 &amp;dest, const long src)" -->
template&lt;typename P1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>assign_pixel</b> (P1 &amp;dest, const long src)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a93ad558cb34ff5f74d81a831b4a71bc3"></a><!-- doxytag: member="dlib::assign_pixel_intensity_helper" ref="a93ad558cb34ff5f74d81a831b4a71bc3" args="(P &amp;dest, const unsigned long &amp;new_intensity)" -->
template&lt;typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1enable__if__c.html">enable_if_c</a>&lt; pixel_traits&lt; P &gt;<br class="typebreak"/>
::grayscale &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>assign_pixel_intensity_helper</b> (P &amp;dest, const unsigned long &amp;new_intensity)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f6926b9bee52d60483f299adc4bf25e"></a><!-- doxytag: member="dlib::get_pixel_intensity_helper" ref="a3f6926b9bee52d60483f299adc4bf25e" args="(const P &amp;src)" -->
template&lt;typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1enable__if__c.html">enable_if_c</a>&lt; pixel_traits&lt; P &gt;<br class="typebreak"/>
::grayscale, unsigned long &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>get_pixel_intensity_helper</b> (const P &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0de1a663136d3a8c409bd1115252defe"></a><!-- doxytag: member="dlib::serialize_floating_point" ref="a0de1a663136d3a8c409bd1115252defe" args="(const T &amp;item, std::ostream &amp;out)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize_floating_point</b> (const T &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a62cc4e230a3ceead473b81ab10cc92d9"></a><!-- doxytag: member="dlib::deserialize_floating_point" ref="a62cc4e230a3ceead473b81ab10cc92d9" args="(T &amp;item, std::istream &amp;in)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize_floating_point</b> (T &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60d8087da7a2b5ceee84fea3b9765fe8"></a><!-- doxytag: member="dlib::serialize" ref="a60d8087da7a2b5ceee84fea3b9765fe8" args="(const float &amp;item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (const float &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a633c78678b1b8e042930c3bcdc3ddf14"></a><!-- doxytag: member="dlib::deserialize" ref="a633c78678b1b8e042930c3bcdc3ddf14" args="(float &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (float &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeda8e7a61ab291286b5ea316e8fc21c8"></a><!-- doxytag: member="dlib::serialize" ref="aeda8e7a61ab291286b5ea316e8fc21c8" args="(const double &amp;item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (const double &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b71c98cbea2ca79cae9f64e7cc8953"></a><!-- doxytag: member="dlib::deserialize" ref="a62b71c98cbea2ca79cae9f64e7cc8953" args="(double &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (double &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad55b3e391e2ed4a3470170eadc37cf2c"></a><!-- doxytag: member="dlib::serialize" ref="ad55b3e391e2ed4a3470170eadc37cf2c" args="(const long double &amp;item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (const long double &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee37ef95181adb0209407e5be1f61503"></a><!-- doxytag: member="dlib::deserialize" ref="aee37ef95181adb0209407e5be1f61503" args="(long double &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (long double &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a83a85a683fa3b9a5bc9cf742bf8bdf02"></a><!-- doxytag: member="dlib::serialize" ref="a83a85a683fa3b9a5bc9cf742bf8bdf02" args="(const std::map&lt; domain, range, compare, alloc &gt; &amp;item, std::ostream &amp;out)" -->
template&lt;typename domain , typename range , typename compare , typename alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const std::map&lt; domain, range, compare, alloc &gt; &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b1b60f9c8429e5ab81c50994896dcf9"></a><!-- doxytag: member="dlib::deserialize" ref="a0b1b60f9c8429e5ab81c50994896dcf9" args="(std::map&lt; domain, range, compare, alloc &gt; &amp;item, std::istream &amp;in)" -->
template&lt;typename domain , typename range , typename compare , typename alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (std::map&lt; domain, range, compare, alloc &gt; &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a7213bb6f1e0dcd5d2fc84ac6b29ff5"></a><!-- doxytag: member="dlib::serialize" ref="a5a7213bb6f1e0dcd5d2fc84ac6b29ff5" args="(const std::vector&lt; T, alloc &gt; &amp;item, std::ostream &amp;out)" -->
template&lt;typename T , typename alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const std::vector&lt; T, alloc &gt; &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a57405739e762674afe117eed2ce6a55f"></a><!-- doxytag: member="dlib::deserialize" ref="a57405739e762674afe117eed2ce6a55f" args="(std::vector&lt; T &gt; &amp;item, std::istream &amp;in)" -->
template&lt;typename T , typename alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (std::vector&lt; T &gt; &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26ecdaff21c62bd613f3e60e2f957cdf"></a><!-- doxytag: member="dlib::serialize" ref="a26ecdaff21c62bd613f3e60e2f957cdf" args="(const std::string &amp;item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (const std::string &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d181320a2ea2281013627f0dd45f78a"></a><!-- doxytag: member="dlib::deserialize" ref="a3d181320a2ea2281013627f0dd45f78a" args="(std::string &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (std::string &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae375af950cbedb6ea620a360dbbde14c"></a><!-- doxytag: member="dlib::serialize" ref="ae375af950cbedb6ea620a360dbbde14c" args="(const enumerable&lt; T &gt; &amp;item, std::ostream &amp;out)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const enumerable&lt; T &gt; &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aabd16ce881f3b10e3114a9ee4d36eb53"></a><!-- doxytag: member="dlib::serialize" ref="aabd16ce881f3b10e3114a9ee4d36eb53" args="(const map_pair&lt; domain, range &gt; &amp;item, std::ostream &amp;out)" -->
template&lt;typename domain , typename range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const map_pair&lt; domain, range &gt; &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a30ba61778b439901187e9861f4697ea4"></a><!-- doxytag: member="dlib::serialize" ref="a30ba61778b439901187e9861f4697ea4" args="(const T(&amp;array)[length], std::ostream &amp;out)" -->
template&lt;typename T , size_t length&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const T(&amp;<a class="el" href="classdlib_1_1array.html">array</a>)[length], std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d2257002446a71b34e2ca9ee8951056"></a><!-- doxytag: member="dlib::deserialize" ref="a2d2257002446a71b34e2ca9ee8951056" args="(T(&amp;array)[length], std::istream &amp;in)" -->
template&lt;typename T , size_t length&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (T(&amp;<a class="el" href="classdlib_1_1array.html">array</a>)[length], std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76bce1d897763e63ec3e3cae29bfe3e3"></a><!-- doxytag: member="dlib::serialize" ref="a76bce1d897763e63ec3e3cae29bfe3e3" args="(bool item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (bool item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a088fe6787c9d6685e26a1d44564fd76c"></a><!-- doxytag: member="dlib::deserialize" ref="a088fe6787c9d6685e26a1d44564fd76c" args="(bool &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (bool &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa14e6433b45994673acf66ad05679460"></a><!-- doxytag: member="dlib::deserialize" ref="aa14e6433b45994673acf66ad05679460" args="(std::vector&lt; T, alloc &gt; &amp;item, std::istream &amp;in)" -->
template&lt;typename T , typename alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (std::vector&lt; T, alloc &gt; &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba03d630ebab1399951ff2efc53258fe"></a><!-- doxytag: member="dlib::serialize" ref="aba03d630ebab1399951ff2efc53258fe" args="(const std::wstring &amp;item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (const std::wstring &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6587fb43c37bb5891a1680271e5d2db6"></a><!-- doxytag: member="dlib::deserialize" ref="a6587fb43c37bb5891a1680271e5d2db6" args="(std::wstring &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (std::wstring &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb3cb215c97a5b5cea0e6224f90ef869"></a><!-- doxytag: member="dlib::serialize" ref="acb3cb215c97a5b5cea0e6224f90ef869" args="(const ustring &amp;item, std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (const ustring &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59ca48e244880b2dee83ccd21a9ff8eb"></a><!-- doxytag: member="dlib::deserialize" ref="a59ca48e244880b2dee83ccd21a9ff8eb" args="(ustring &amp;item, std::istream &amp;in)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (ustring &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="affd2021d7bd2c3b01fd232c92b0cb82a"></a><!-- doxytag: member="dlib::serialize" ref="affd2021d7bd2c3b01fd232c92b0cb82a" args="(const std::complex&lt; T &gt; &amp;item, std::ostream &amp;out)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const std::complex&lt; T &gt; &amp;item, std::ostream &amp;out)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3440b6f4db4ad716e217da64cadbb14d"></a><!-- doxytag: member="dlib::deserialize" ref="a3440b6f4db4ad716e217da64cadbb14d" args="(std::complex&lt; T &gt; &amp;item, std::istream &amp;in)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (std::complex&lt; T &gt; &amp;item, std::istream &amp;in)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a500f78eac0d057fd1023a6bb025ce918"></a><!-- doxytag: member="dlib::qsort_array" ref="a500f78eac0d057fd1023a6bb025ce918" args="(T &amp;array, unsigned long left, unsigned long right, const compare &amp;comp)" -->
template&lt;typename T , typename compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>qsort_array</b> (T &amp;<a class="el" href="classdlib_1_1array.html">array</a>, unsigned long left, unsigned long right, const compare &amp;comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#ad2483eaef67b51922017370294317395">hsort_array</a> (T &amp;<a class="el" href="classdlib_1_1array.html">array</a>, unsigned long left, unsigned long right, const compare &amp;comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a67b8e8c3f84cc73d4335f36131d6dd3f">isort_array</a> (T &amp;<a class="el" href="classdlib_1_1array.html">array</a>, unsigned long left, unsigned long right, const compare &amp;comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a603b4c76cedf8bff5975b76817f27eaa">qsort_array</a> (T &amp;<a class="el" href="classdlib_1_1array.html">array</a>, unsigned long left, unsigned long right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#ad6abbf5d4ec2109706476146835059b7">hsort_array</a> (T &amp;<a class="el" href="classdlib_1_1array.html">array</a>, unsigned long left, unsigned long right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#af630f6e36af2fed569135ae72246e016">isort_array</a> (T &amp;<a class="el" href="classdlib_1_1array.html">array</a>, unsigned long left, unsigned long right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a963489c2ce136f1924ae92bf47ab12a7"></a><!-- doxytag: member="dlib::get_stack_trace" ref="a963489c2ce136f1924ae92bf47ab12a7" args="()" -->
const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_stack_trace</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad04e79a06dc35940470c2d4422051d21"></a><!-- doxytag: member="dlib::operator==" ref="ad04e79a06dc35940470c2d4422051d21" args="(const std_allocator&lt; T1, M1 &gt; &amp;, const std_allocator&lt; T2, M2 &gt; &amp;)" -->
template&lt;typename T1 , typename M1 , typename T2 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a>&lt; T1, M1 &gt; &amp;, const <a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a>&lt; T2, M2 &gt; &amp;)  throw ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5419d341c5a35f9fa10c05cc5291f851"></a><!-- doxytag: member="dlib::operator!=" ref="a5419d341c5a35f9fa10c05cc5291f851" args="(const std_allocator&lt; T1, M1 &gt; &amp;, const std_allocator&lt; T2, M2 &gt; &amp;)" -->
template&lt;typename T1 , typename M1 , typename T2 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a>&lt; T1, M1 &gt; &amp;, const <a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a>&lt; T2, M2 &gt; &amp;)  throw ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acf38fa94722837a9a6c027cdedb3d95c"></a><!-- doxytag: member="dlib::swap" ref="acf38fa94722837a9a6c027cdedb3d95c" args="(std_allocator&lt; T, M &gt; &amp;a, std_allocator&lt; T, M &gt; &amp;b)" -->
template&lt;typename T , typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a>&lt; T, M &gt; &amp;a, <a class="el" href="classdlib_1_1std__allocator.html">std_allocator</a>&lt; T, M &gt; &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb7adb34b3185802d0bb88a1cdc74e0a"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="aeb7adb34b3185802d0bb88a1cdc74e0a" args="(sizeof(uint8)==1)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(uint8)==1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35a780750c26bf4dbdf1c35fe1a56c3e"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="a35a780750c26bf4dbdf1c35fe1a56c3e" args="(sizeof(uint16)==2)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(uint16)==2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acedb24147b035ef793368d07f6e442a9"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="acedb24147b035ef793368d07f6e442a9" args="(sizeof(uint32)==4)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(uint32)==4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbff5c3e08b2c288cb019376894949a"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="acfbff5c3e08b2c288cb019376894949a" args="(sizeof(uint64)==8)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(<a class="el" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">uint64</a>)==8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec561058332d9a7ccc288ff03c0a3452"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="aec561058332d9a7ccc288ff03c0a3452" args="(sizeof(int8)==1)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(int8)==1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf49734f8889a0230d2167d84acc3987"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="abf49734f8889a0230d2167d84acc3987" args="(sizeof(int16)==2)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(int16)==2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35f54002263fc38d786ef9c76668f950"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="a35f54002263fc38d786ef9c76668f950" args="(sizeof(int32)==4)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(int32)==4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66818c36792273096fbf0e1168764bd1"></a><!-- doxytag: member="dlib::COMPILE_TIME_ASSERT" ref="a66818c36792273096fbf0e1168764bd1" args="(sizeof(int64)==8)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_ASSERT</b> (sizeof(int64)==8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedlib.html#a87847cba5edee8c23c0970bbe19fa3ce">zero_extend_cast</a> (const U val)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fb617da1a86ef17870d75dd52a8112a"></a><!-- doxytag: member="dlib::mem" ref="a7fb617da1a86ef17870d75dd52a8112a" args="" -->
union <a class="el" href="uniondlib_1_1mem__block.html">dlib::mem_block</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>mem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf90d7d28af819b88c07f7720ba126cb"></a><!-- doxytag: member="dlib::data" ref="aaf90d7d28af819b88c07f7720ba126cb" args="" -->
void *const&nbsp;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>requires</p>
<ul>
<li>charT == char or wchar_t</li>
<li>str == a string or character literal ensures</li>
<li>returns the literal in the form of a charT type literal. !</li>
</ul>
<p>There are two global functions in the <a class="el" href="namespacedlib.html">dlib</a> namespace that provide serialization and deserialization support. Their signatures and specifications are as follows:</p>
<p>void serialize ( const serializable_type&amp; item, std::ostream&amp; out ); /!* ensures</p>
<ul>
<li>writes the state of item to the output stream out</li>
<li>if (serializable_type implements the enumerable interface) then<ul>
<li>item.at_start() == true throws</li>
</ul>
</li>
<li><a class="el" href="classdlib_1_1serialization__error.html">serialization_error</a> This exception is thrown if there is some problem which prevents us from successfully writing item to the output stream.</li>
<li>any other exception !/</li>
</ul>
<p>void deserialize ( serializable_type&amp; item, std::istream&amp; in ); /!* ensures</p>
<ul>
<li>item == a deserialized copy of the serializable_type that was in the input stream in.</li>
<li>if (serializable_type implements the enumerable interface) then<ul>
<li>item.at_start() == true throws</li>
</ul>
</li>
<li><a class="el" href="classdlib_1_1serialization__error.html">serialization_error</a> This exception is thrown if there is some problem which prevents us from successfully deserializing item from the input stream. If this exception is thrown then item will have an initial value for its type.</li>
<li>any other exception !/</li>
</ul>
<p>This file provides serialization support to the following object types:</p>
<ul>
<li>The C++ base types (NOT including pointer types)</li>
<li>std::string</li>
<li>std::wstring</li>
<li>std::vector</li>
<li>std::map</li>
<li>std::complex</li>
<li><a class="el" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">dlib::uint64</a></li>
<li>enumerable&lt;T&gt; where T is a serializable type</li>
<li>map_pair&lt;D,R&gt; where D and R are both serializable types.</li>
<li>C style arrays of serializable types</li>
</ul>
<p>This file provides deserialization support to the following object types:</p>
<ul>
<li>The C++ base types (NOT including pointer types)</li>
<li>std::string</li>
<li>std::wstring</li>
<li>std::vector</li>
<li>std::map</li>
<li>std::complex</li>
<li><a class="el" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">dlib::uint64</a></li>
<li>C style arrays of serializable types</li>
</ul>
<p>Support for deserialization of objects which implement the enumerable or map_pair interfaces is the responsibility of those objects.</p>
<p>Note that you can deserialize an integer value to any integral type (except for a char type) if its value will fit into the target integer type. I.e. the types short, int, long, unsigned short, unsigned int, unsigned long, and <a class="el" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">dlib::uint64</a> can all receive serialized data from each other so long as the actual serizlied value fits within the receiving integral type's range.</p>
<p>Also note that for any container to be serializable the type of object it contains must be serializable.</p>
<p>FILE STREAMS If you are serializing to and from file streams it is important to remember to <a class="el" href="classdlib_1_1set.html">set</a> the file streams to binary mode using the std::ios::binary flag.</p>
<p>INTEGRAL SERIALIZATION FORMAT All C++ integral types (except the char types) are serialized to the following format: The first byte is a control byte. It tells you if the serialized number is positive or negative and also tells you how many of the following bytes are part of the number. The absolute value of the number is stored in little endian byte order and follows the control byte.</p>
<p>The control byte: The high order bit of the control byte is a flag that tells you if the encoded number is negative or not. It is <a class="el" href="classdlib_1_1set.html">set</a> to 1 when the number is negative and 0 otherwise. The 4 low order bits of the control byte represent an unsigned number and tells you how many of the following bytes are part of the encoded number.</p>
<p>! </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a61113f8b6b3e4ccb66deca9355c8f65d"></a><!-- doxytag: member="dlib::uint64" ref="a61113f8b6b3e4ccb66deca9355c8f65d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="namespacedlib.html#a61113f8b6b3e4ccb66deca9355c8f65d">dlib::uint64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>uint64 is a typedef for an unsigned integer that is exactly 64 bits wide. uint32 is a typedef for an unsigned integer that is exactly 32 bits wide. uint16 is a typedef for an unsigned integer that is exactly 16 bits wide. uint8 is a typedef for an unsigned integer that is exactly 8 bits wide.</p>
<p>int64 is a typedef for an integer that is exactly 64 bits wide. int32 is a typedef for an integer that is exactly 32 bits wide. int16 is a typedef for an integer that is exactly 16 bits wide. int8 is a typedef for an integer that is exactly 8 bits wide. ! </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a3d0eb509fdefecd0e9f75bab1a0c97d9"></a><!-- doxytag: member="dlib::general_return_codes" ref="a3d0eb509fdefecd0e9f75bab1a0c97d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedlib.html#a3d0eb509fdefecd0e9f75bab1a0c97d9">dlib::general_return_codes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Here is where I define my return codes. It is important that they all be &lt; 0. ! </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5756e98c19859a24eb42d6b906808095"></a><!-- doxytag: member="dlib::assign_pixel" ref="a5756e98c19859a24eb42d6b906808095" args="(P &amp;dest, const long src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::assign_pixel </td>
          <td>(</td>
          <td class="paramtype">P &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>pixel_traits</li>
</ul>
<p>must be defined ensures</p>
<ul>
<li>performs assign_pixel(dest, static_cast&lt;unsigned long&gt;(max(0,src))) ! </li>
</ul>

</div>
</div>
<a class="anchor" id="a88c00fa9d7ea718f6198c72451378f2a"></a><!-- doxytag: member="dlib::assign_pixel" ref="a88c00fa9d7ea718f6198c72451378f2a" args="(P &amp;dest, const int src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::assign_pixel </td>
          <td>(</td>
          <td class="paramtype">P &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>pixel_traits&lt;P1&gt; must be defined</li>
<li>pixel_traits&lt;P2&gt; must be defined ensures</li>
<li>if (P1 and P2 are the same type of pixel) then<ul>
<li>simply coppies the value of src into dest. In other words, dest will be identical to src after this function returns.</li>
</ul>
</li>
<li>else if (P1 and P2 are not the same type of pixel) then<ul>
<li>assigns pixel src to pixel dest and does any necessary color space conversions.</li>
<li>When converting from a grayscale color space with more than 255 values the pixel intensity is saturated at pixel_traits&lt;P1&gt;::max().</li>
<li>if (the dest pixel has an alpha channel and the src pixel doesn't) then<ul>
<li>dest.alpha == 255</li>
</ul>
</li>
<li>else if (the src pixel has an alpha channel but the dest pixel doesn't) then<ul>
<li>dest == the original dest value blended with the src value according to the alpha channel in src. (i.e. dest == src*(alpha/255) + dest*(1-alpha/255)) ! </li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a3b9a3281788e2c68adbe5e81265aaeb2"></a><!-- doxytag: member="dlib::assign_pixel_intensity" ref="a3b9a3281788e2c68adbe5e81265aaeb2" args="(P &amp;dest, const unsigned long new_intensity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::assign_pixel_intensity </td>
          <td>(</td>
          <td class="paramtype">P &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&nbsp;</td>
          <td class="paramname"> <em>new_intensity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>pixel_traits</li>
</ul>
<p>must be defined ensures</p>
<ul>
<li>if (pixel_traits&lt;P&gt;::grayscale == true) then<ul>
<li>returns src</li>
</ul>
</li>
<li>else<ul>
<li>converts src to the HSI color space and returns the intensity ! </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ab31aceb3894feb837313ad0add9d9294"></a><!-- doxytag: member="dlib::assign_zero_if_built_in_scalar_type" ref="ab31aceb3894feb837313ad0add9d9294" args="(T &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structdlib_1_1is__built__in__scalar__type.html">is_built_in_scalar_type</a>&lt; T &gt;, void &gt;::type dlib::assign_zero_if_built_in_scalar_type </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A assign_zero_if_built_in_scalar_type</p>
<p>This function assigns its argument the value of 0 if it is a built in scalar type according to the is_built_in_scalar_type&lt;&gt; template. If it isn't a built in scalar type then it does nothing. ! </p>

</div>
</div>
<a class="anchor" id="a5291c6d8fcf1bd624eaa7f908ea137bf"></a><!-- doxytag: member="dlib::deserialize" ref="a5291c6d8fcf1bd624eaa7f908ea137bf" args="(hsi_pixel &amp;item, std::istream &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::deserialize </td>
          <td>(</td>
          <td class="paramtype">hsi_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides serialization support for the <a class="el" href="structdlib_1_1hsi__pixel.html">hsi_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="a59df13454703d695429ac5af04c8cb35"></a><!-- doxytag: member="dlib::deserialize" ref="a59df13454703d695429ac5af04c8cb35" args="(rgb_alpha_pixel &amp;item, std::istream &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::deserialize </td>
          <td>(</td>
          <td class="paramtype">rgb_alpha_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides serialization support for the <a class="el" href="structdlib_1_1rgb__alpha__pixel.html">rgb_alpha_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="a2ffefe1102a7c709e26a23b4f2c7668c"></a><!-- doxytag: member="dlib::deserialize" ref="a2ffefe1102a7c709e26a23b4f2c7668c" args="(bgr_pixel &amp;item, std::istream &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::deserialize </td>
          <td>(</td>
          <td class="paramtype">bgr_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides serialization support for the <a class="el" href="structdlib_1_1bgr__pixel.html">bgr_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="a5e5ead1e1179ca255a628e46a55d12ce"></a><!-- doxytag: member="dlib::deserialize" ref="a5e5ead1e1179ca255a628e46a55d12ce" args="(rgb_pixel &amp;item, std::istream &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::deserialize </td>
          <td>(</td>
          <td class="paramtype">rgb_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides serialization support for the <a class="el" href="structdlib_1_1rgb__pixel.html">rgb_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="a7a50a190179be95c0d38aaa92960d1dc"></a><!-- doxytag: member="dlib::exchange" ref="a7a50a190179be95c0d38aaa92960d1dc" args="(T &amp;a, T &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function does the exact same thing that global swap does and it does it by just calling swap. But a lot of compilers have problems doing a Koenig Lookup and the fact that this has a different name (global swap has the same name as the member functions called swap) makes them compile right.</p>
<p>So this is a workaround but not too ugly of one. But hopefully I get get rid of this in a few years. So this function is alredy deprecated.</p>
<p>This also means you should NOT use this function in your own code unless you have to support an old buggy compiler that benefits from this hack. ! </p>

</div>
</div>
<a class="anchor" id="acadbad5cd1cbaf9f188eb56b518a0f01"></a><!-- doxytag: member="dlib::get_pixel_intensity" ref="acadbad5cd1cbaf9f188eb56b518a0f01" args="(const P &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned long dlib::get_pixel_intensity </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>pixel_traits</li>
</ul>
<p>must be defined ensures</p>
<ul>
<li>performs assign_pixel(dest, static_cast&lt;unsigned long&gt;(max(0,src))) ! </li>
</ul>

</div>
</div>
<a class="anchor" id="ad6abbf5d4ec2109706476146835059b7"></a><!-- doxytag: member="dlib::hsort_array" ref="ad6abbf5d4ec2109706476146835059b7" args="(T &amp;array, unsigned long left, unsigned long right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::hsort_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T implements operator[]</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be comparable by std::less</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be swappable by a global swap()</li>
<li>left and right are within the bounds of <a class="el" href="classdlib_1_1array.html">array</a> i.e. <a class="el" href="classdlib_1_1array.html">array</a>[left] and <a class="el" href="classdlib_1_1array.html">array</a>[right] are valid elements</li>
<li>left &lt;= right ensures</li>
<li>for all elements in array between and including left and right the ith element is &lt; the i+1 element</li>
<li>sorts using a quick sort algorithm ! </li>
</ul>

</div>
</div>
<a class="anchor" id="ad2483eaef67b51922017370294317395"></a><!-- doxytag: member="dlib::hsort_array" ref="ad2483eaef67b51922017370294317395" args="(T &amp;array, unsigned long left, unsigned long right, const compare &amp;comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::hsort_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const compare &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T implements operator[]</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be comparable by comp where comp is a function object with the same syntax as std::less&lt;&gt;</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be swappable by a global swap()</li>
<li>left and right are within the bounds of <a class="el" href="classdlib_1_1array.html">array</a> i.e. <a class="el" href="classdlib_1_1array.html">array</a>[left] and <a class="el" href="classdlib_1_1array.html">array</a>[right] are valid elements</li>
<li>left &lt;= right ensures</li>
<li>for all elements in array between and including left and right the ith element is &lt; the i+1 element</li>
<li>sorts using a quick sort algorithm ! </li>
</ul>

</div>
</div>
<a class="anchor" id="af630f6e36af2fed569135ae72246e016"></a><!-- doxytag: member="dlib::isort_array" ref="af630f6e36af2fed569135ae72246e016" args="(T &amp;array, unsigned long left, unsigned long right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::isort_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T implements operator[]</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be comparable by std::less</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be swappable by a global swap()</li>
<li>left and right are within the bounds of <a class="el" href="classdlib_1_1array.html">array</a> i.e. <a class="el" href="classdlib_1_1array.html">array</a>[left] and <a class="el" href="classdlib_1_1array.html">array</a>[right] are valid elements</li>
<li>left &lt;= right ensures</li>
<li>for all elements in array between and including left and right the ith element is &lt; the i+1 element</li>
<li>sorts using a heapsort algorithm ! </li>
</ul>

</div>
</div>
<a class="anchor" id="a67b8e8c3f84cc73d4335f36131d6dd3f"></a><!-- doxytag: member="dlib::isort_array" ref="a67b8e8c3f84cc73d4335f36131d6dd3f" args="(T &amp;array, unsigned long left, unsigned long right, const compare &amp;comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::isort_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const compare &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T implements operator[]</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be comparable by comp where comp is a function object with the same syntax as std::less&lt;&gt;</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be swappable by a global swap()</li>
<li>left and right are within the bounds of <a class="el" href="classdlib_1_1array.html">array</a> i.e. <a class="el" href="classdlib_1_1array.html">array</a>[left] and <a class="el" href="classdlib_1_1array.html">array</a>[right] are valid elements</li>
<li>left &lt;= right ensures</li>
<li>for all elements in array between and including left and right the ith element is &lt; the i+1 element</li>
<li>sorts using a heapsort algorithm ! </li>
</ul>

</div>
</div>
<a class="anchor" id="af2608709700ae61f169fd4687e406267"></a><!-- doxytag: member="dlib::median" ref="af2608709700ae61f169fd4687e406267" args="(T &amp;one, T &amp;two, T &amp;three)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::median </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>two</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>three</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T implements operator&lt;</li>
<li>T is swappable by a global swap() ensures</li>
<li>one is the median</li>
<li>one, two, and three is some permutation of one, two, and three. ! </li>
</ul>

</div>
</div>
<a class="anchor" id="a36bcf970b14e81d1c300283a52d64142"></a><!-- doxytag: member="dlib::put_in_range" ref="a36bcf970b14e81d1c300283a52d64142" args="(const T &amp;a, const T &amp;b, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dlib::put_in_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T is a type that looks like double, float, int, or so forth ensures</li>
<li>if (val is within the range [a,b]) then<ul>
<li>returns val</li>
</ul>
</li>
<li>else<ul>
<li>returns the end of the range [a,b] that is closest to val ! </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a603b4c76cedf8bff5975b76817f27eaa"></a><!-- doxytag: member="dlib::qsort_array" ref="a603b4c76cedf8bff5975b76817f27eaa" args="(T &amp;array, unsigned long left, unsigned long right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dlib::qsort_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>T implements operator[]</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be comparable by comp where comp is a function object with the same syntax as std::less&lt;&gt;</li>
<li>the items in <a class="el" href="classdlib_1_1array.html">array</a> must be swappable by a global swap()</li>
<li>left and right are within the bounds of <a class="el" href="classdlib_1_1array.html">array</a> i.e. <a class="el" href="classdlib_1_1array.html">array</a>[left] and <a class="el" href="classdlib_1_1array.html">array</a>[right] are valid elements</li>
<li>left &lt;= right ensures</li>
<li>for all elements in array between and including left and right the ith element is &lt; the i+1 element</li>
<li>sorts using an insertion sort algorithm ! </li>
</ul>

</div>
</div>
<a class="anchor" id="add718e65e3023a2abd8eb04200e81b52"></a><!-- doxytag: member="dlib::serialize" ref="add718e65e3023a2abd8eb04200e81b52" args="(const hsi_pixel &amp;item, std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::serialize </td>
          <td>(</td>
          <td class="paramtype">const hsi_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides deserialization support for the <a class="el" href="structdlib_1_1rgb__alpha__pixel.html">rgb_alpha_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="abbbd5224f9387eef940579cdf3fd4a13"></a><!-- doxytag: member="dlib::serialize" ref="abbbd5224f9387eef940579cdf3fd4a13" args="(const rgb_alpha_pixel &amp;item, std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::serialize </td>
          <td>(</td>
          <td class="paramtype">const rgb_alpha_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides deserialization support for the <a class="el" href="structdlib_1_1bgr__pixel.html">bgr_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="aefd5ce982b258dc62d2c4a657278a492"></a><!-- doxytag: member="dlib::serialize" ref="aefd5ce982b258dc62d2c4a657278a492" args="(const bgr_pixel &amp;item, std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::serialize </td>
          <td>(</td>
          <td class="paramtype">const bgr_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>provides deserialization support for the <a class="el" href="structdlib_1_1rgb__pixel.html">rgb_pixel</a> struct ! </p>

</div>
</div>
<a class="anchor" id="ac78b72e65600a0d25ac3224539794fc2"></a><!-- doxytag: member="dlib::serialize" ref="ac78b72e65600a0d25ac3224539794fc2" args="(const rgb_pixel &amp;item, std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlib::serialize </td>
          <td>(</td>
          <td class="paramtype">const rgb_pixel &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>pixel_traits</li>
</ul>
<p>must be defined ensures</p>
<ul>
<li>let val == min(new_intensity, pixel_traits&lt;P&gt;::max())</li>
<li>get_pixel_intensity(dest) == val</li>
<li>if (the dest pixel has an alpha channel) then<ul>
<li>dest.alpha == dest.alpha ! </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aa718d15067f15dd851a98eb1088131ae"></a><!-- doxytag: member="dlib::square_root" ref="aa718d15067f15dd851a98eb1088131ae" args="(unsigned long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long dlib::square_root </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>requires</p>
<ul>
<li>value &lt;= 2^32 - 1 ensures</li>
<li>returns the square root of value. if the square root is not an integer then it will be rounded up to the nearest integer. ! </li>
</ul>

</div>
</div>
<a class="anchor" id="a87847cba5edee8c23c0970bbe19fa3ce"></a><!-- doxytag: member="dlib::zero_extend_cast" ref="a87847cba5edee8c23c0970bbe19fa3ce" args="(const U val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dlib::zero_extend_cast </td>
          <td>(</td>
          <td class="paramtype">const U&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ensures</p>
<ul>
<li>sizeof(unsigned_type&lt;T&gt;::type) == sizeof(T)</li>
<li>unsigned_type&lt;T&gt;::type is an unsigned integral type !</li>
</ul>
<p>requires</p>
<ul>
<li>U and T are integral types ensures</li>
<li>let ut be a typedef for unsigned_type&lt;U&gt;::type</li>
<li>return static_cast&lt;T&gt;(static_cast&lt;ut&gt;(val)); ! </li>
</ul>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Feb 17 11:58:06 2010 for Procedural Game Plot Generation Prototype by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
