\hypertarget{namespacedlib}{
\section{dlib Namespace Reference}
\label{namespacedlib}\index{dlib@{dlib}}
}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \hyperlink{namespacedlib_1_1sort__helpers}{sort\_\-helpers}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classdlib_1_1is__pointer__type}{is\_\-pointer\_\-type}
\item 
class \hyperlink{classdlib_1_1is__pointer__type_3_01T_01_5_01_4}{is\_\-pointer\_\-type$<$ T $\ast$ $>$}
\item 
struct \hyperlink{structdlib_1_1is__const__type}{is\_\-const\_\-type}
\item 
struct \hyperlink{structdlib_1_1is__const__type_3_01const_01T_01_4}{is\_\-const\_\-type$<$ const T $>$}
\item 
class \hyperlink{classdlib_1_1is__same__type}{is\_\-same\_\-type}
\item 
class \hyperlink{classdlib_1_1is__same__type_3_01T_00_01T_01_4}{is\_\-same\_\-type$<$ T, T $>$}
\item 
struct \hyperlink{structdlib_1_1is__convertible}{is\_\-convertible}
\item 
struct \hyperlink{structdlib_1_1is__unsigned__type}{is\_\-unsigned\_\-type}
\item 
struct \hyperlink{structdlib_1_1is__signed__type}{is\_\-signed\_\-type}
\item 
class \hyperlink{classdlib_1_1copy__functor}{copy\_\-functor}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01297db704ac0ccd7cdf569f49ff1837f4}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_011_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01e6d4ee9dd0db82c25ad3e5e162ffcf57}{static\_\-switch$<$ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_011_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_013c4ac657bc48737c62a5b545ecf666e2}{static\_\-switch$<$ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_011_00_010_00_010_00_010_00_010_00_010_00_010_00_01f20039fe97478cfcdfb8a6fb10d88c23}{static\_\-switch$<$ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_011_00_010_00_010_00_010_00_010_00_010_00_017e7e1ea6f90a3743d68a10bc9ac43767}{static\_\-switch$<$ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_011_00_010_00_010_00_010_00_010_00_01ff4b50cffbfc7efeb2ebcd8ac49664ca}{static\_\-switch$<$ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_011_00_010_00_010_00_010_00_01065a8f5a38c76e0fbec03f2ecf64307a}{static\_\-switch$<$ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010_00_010_00_01f96a27221d42a17b5e8ff3b09c0ae4ae}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010_00_0105236f4c56e9666de491dbb566b29360}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011_00_010dd8c605dbfd043e236f91723a992215}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_011e8c10a795cabaf3f5d590d7d2ed509c}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0145cbcc58af0c0409c47cc48fc11394ec}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0147e6a475a446e40bfc581407a8174f9f}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_01de46d05550779d2bbe7720ab7bfdb3cc}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_016cef4822784544663fb033f63ec96728}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 $>$}
\item 
struct \hyperlink{structdlib_1_1static__switch_3_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_010_00_0146ef5bf350d722d5ffb766430493f3da}{static\_\-switch$<$ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type}{is\_\-built\_\-in\_\-scalar\_\-type}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01float_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ float $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01double_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ double $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01long_01double_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ long double $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01short_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ short $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01int_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ int $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01long_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ long $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01unsigned_01short_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ unsigned short $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01unsigned_01int_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ unsigned int $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01unsigned_01long_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ unsigned long $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01uint64_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ uint64 $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01char_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ char $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01signed_01char_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ signed char $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01unsigned_01char_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ unsigned char $>$}
\item 
struct \hyperlink{structdlib_1_1is__built__in__scalar__type_3_01wchar__t_01_4}{is\_\-built\_\-in\_\-scalar\_\-type$<$ wchar\_\-t $>$}
\item 
struct \hyperlink{structdlib_1_1tabs}{tabs}
\item 
struct \hyperlink{structdlib_1_1tabs_3_01x_00_01typename_01enable__if__c_3_07x_3_010_08_4_1_1type_01_4_02const_01s5583e8a7aa9817e380d6b80c74f287b0}{tabs$<$ x, typename enable\_\-if\_\-c$<$(x$<$ 0)$>$::type $>$\{const static long value=-\/x;\};template$<$ long x, long y, typename enabled=void $>$struct tmax\{const static long value=x;\};template$<$ long x, long y $>$struct tmax$<$ x, y, typename enable\_\-if\_\-c$<$(y $>$ x)$>$::type $>$}
\item 
struct \hyperlink{structdlib_1_1tmin}{tmin}
\item 
union \hyperlink{uniondlib_1_1mem__block}{mem\_\-block}
\item 
class \hyperlink{classdlib_1_1array}{array}
\item 
class \hyperlink{classdlib_1_1array2d}{array2d}
\item 
struct \hyperlink{structdlib_1_1compile__time__assert_3_01true_01_4}{compile\_\-time\_\-assert$<$ true $>$}
\item 
struct \hyperlink{structdlib_1_1assert__are__same__type_3_01T_00_01T_01_4}{assert\_\-are\_\-same\_\-type$<$ T, T $>$}
\item 
struct \hyperlink{structdlib_1_1assert__are__not__same__type}{assert\_\-are\_\-not\_\-same\_\-type}
\item 
struct \hyperlink{structdlib_1_1assert__are__not__same__type_3_01T_00_01T_01_4}{assert\_\-are\_\-not\_\-same\_\-type$<$ T, T $>$}
\item 
class \hyperlink{classdlib_1_1base64}{base64}
\item 
class \hyperlink{classdlib_1_1assignment}{assignment}
\item 
class \hyperlink{classdlib_1_1joint__probability__table}{joint\_\-probability\_\-table}
\item 
class \hyperlink{classdlib_1_1conditional__probability__table}{conditional\_\-probability\_\-table}
\item 
class \hyperlink{classdlib_1_1bayes__node}{bayes\_\-node}
\item 
class \hyperlink{classdlib_1_1bayesian__network__gibbs__sampler}{bayesian\_\-network\_\-gibbs\_\-sampler}
\item 
class \hyperlink{classdlib_1_1bayesian__network__join__tree}{bayesian\_\-network\_\-join\_\-tree}
\item 
class \hyperlink{classdlib_1_1bigint}{bigint}
\item 
class \hyperlink{classdlib_1_1binary__search__tree}{binary\_\-search\_\-tree}
\item 
class \hyperlink{classdlib_1_1bit__stream}{bit\_\-stream}
\item 
class \hyperlink{classdlib_1_1bound__function__pointer}{bound\_\-function\_\-pointer}
\item 
class \hyperlink{classdlib_1_1byte__orderer}{byte\_\-orderer}
\item 
class \hyperlink{classdlib_1_1cmd__line__parser}{cmd\_\-line\_\-parser}
\item 
class \hyperlink{classdlib_1_1compress__stream}{compress\_\-stream}
\item 
class \hyperlink{classdlib_1_1conditioning__class}{conditioning\_\-class}
\item 
class \hyperlink{classdlib_1_1config__reader}{config\_\-reader}
\item 
class \hyperlink{classdlib_1_1cpp__pretty__printer}{cpp\_\-pretty\_\-printer}
\item 
class \hyperlink{classdlib_1_1cpp__tokenizer}{cpp\_\-tokenizer}
\item 
class \hyperlink{classdlib_1_1crc32}{crc32}
\item 
class \hyperlink{classdlib_1_1directed__graph}{directed\_\-graph}
\item 
class \hyperlink{classdlib_1_1entropy__decoder}{entropy\_\-decoder}
\item 
class \hyperlink{classdlib_1_1entropy__decoder__model}{entropy\_\-decoder\_\-model}
\item 
class \hyperlink{classdlib_1_1entropy__encoder}{entropy\_\-encoder}
\item 
class \hyperlink{classdlib_1_1entropy__encoder__model}{entropy\_\-encoder\_\-model}
\item 
class \hyperlink{classdlib_1_1error}{error}
\item 
class \hyperlink{classdlib_1_1fatal__error}{fatal\_\-error}
\item 
class \hyperlink{classdlib_1_1gui__error}{gui\_\-error}
\item 
class \hyperlink{classdlib_1_1socket__error}{socket\_\-error}
\item 
class \hyperlink{classdlib_1_1thread__error}{thread\_\-error}
\item 
class \hyperlink{classdlib_1_1graph}{graph}
\item 
class \hyperlink{classdlib_1_1hash__map}{hash\_\-map}
\item 
class \hyperlink{classdlib_1_1hash__set}{hash\_\-set}
\item 
class \hyperlink{classdlib_1_1hash__table}{hash\_\-table}
\item 
struct \hyperlink{structdlib_1_1default__is__kind__value}{default\_\-is\_\-kind\_\-value}
\item 
struct \hyperlink{structdlib_1_1is__graph}{is\_\-graph}
\item 
struct \hyperlink{structdlib_1_1is__directed__graph}{is\_\-directed\_\-graph}
\item 
struct \hyperlink{structdlib_1_1is__matrix}{is\_\-matrix}
\item 
struct \hyperlink{structdlib_1_1is__std__vector}{is\_\-std\_\-vector}
\item 
struct \hyperlink{structdlib_1_1is__rand}{is\_\-rand}
\item 
struct \hyperlink{structdlib_1_1is__std__vector_3_01std_1_1vector_3_01T_00_01alloc_01_4_01_4}{is\_\-std\_\-vector$<$ std::vector$<$ T, alloc $>$ $>$}
\item 
struct \hyperlink{structdlib_1_1is__std__vector_3_01T_01_6_01_4}{is\_\-std\_\-vector$<$ T \& $>$}
\item 
struct \hyperlink{structdlib_1_1is__std__vector_3_01const_01T_01_6_01_4}{is\_\-std\_\-vector$<$ const T \& $>$}
\item 
struct \hyperlink{structdlib_1_1is__std__vector_3_01const_01T_01_4}{is\_\-std\_\-vector$<$ const T $>$}
\item 
class \hyperlink{classdlib_1_1linker}{linker}
\item 
class \hyperlink{classdlib_1_1lz77__buffer}{lz77\_\-buffer}
\item 
class \hyperlink{classdlib_1_1lzp__buffer}{lzp\_\-buffer}
\item 
class \hyperlink{classdlib_1_1map}{map}
\item 
class \hyperlink{classdlib_1_1member__function__pointer}{member\_\-function\_\-pointer}
\item 
class \hyperlink{classdlib_1_1memory__manager}{memory\_\-manager}
\item 
class \hyperlink{classdlib_1_1memory__manager__global}{memory\_\-manager\_\-global}
\item 
class \hyperlink{classdlib_1_1memory__manager__stateless}{memory\_\-manager\_\-stateless}
\item 
class \hyperlink{classdlib_1_1mlp}{mlp}
\item 
class \hyperlink{classdlib_1_1pipe}{pipe}
\item 
struct \hyperlink{structdlib_1_1rgb__pixel}{rgb\_\-pixel}
\item 
struct \hyperlink{structdlib_1_1bgr__pixel}{bgr\_\-pixel}
\item 
struct \hyperlink{structdlib_1_1rgb__alpha__pixel}{rgb\_\-alpha\_\-pixel}
\item 
struct \hyperlink{structdlib_1_1hsi__pixel}{hsi\_\-pixel}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01rgb__pixel_01_4}{pixel\_\-traits$<$ rgb\_\-pixel $>$}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01bgr__pixel_01_4}{pixel\_\-traits$<$ bgr\_\-pixel $>$}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01rgb__alpha__pixel_01_4}{pixel\_\-traits$<$ rgb\_\-alpha\_\-pixel $>$}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01hsi__pixel_01_4}{pixel\_\-traits$<$ hsi\_\-pixel $>$}
\item 
struct \hyperlink{structdlib_1_1grayscale__pixel__traits}{grayscale\_\-pixel\_\-traits}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01unsigned_01char_01_4}{pixel\_\-traits$<$ unsigned char $>$}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01unsigned_01short_01_4}{pixel\_\-traits$<$ unsigned short $>$}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01unsigned_01int_01_4}{pixel\_\-traits$<$ unsigned int $>$}
\item 
struct \hyperlink{structdlib_1_1pixel__traits_3_01unsigned_01long_01_4}{pixel\_\-traits$<$ unsigned long $>$}
\item 
class \hyperlink{classdlib_1_1queue}{queue}
\item 
class \hyperlink{classdlib_1_1rand}{rand}
\item 
class \hyperlink{classdlib_1_1reference__counter}{reference\_\-counter}
\item 
class \hyperlink{classdlib_1_1sequence}{sequence}
\item 
class \hyperlink{classdlib_1_1serialization__error}{serialization\_\-error}
\item 
class \hyperlink{classdlib_1_1server}{server}
\item 
class \hyperlink{classdlib_1_1set}{set}
\item 
class \hyperlink{classdlib_1_1sliding__buffer}{sliding\_\-buffer}
\item 
class \hyperlink{classdlib_1_1sockstreambuf}{sockstreambuf}
\item 
class \hyperlink{classdlib_1_1stack}{stack}
\item 
class \hyperlink{classdlib_1_1static__map}{static\_\-map}
\item 
class \hyperlink{classdlib_1_1static__set}{static\_\-set}
\item 
class \hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}
\item 
class \hyperlink{classdlib_1_1std__allocator_3_01void_00_01M_01_4}{std\_\-allocator$<$ void, M $>$}
\item 
struct \hyperlink{structdlib_1_1std__alloc__compare}{std\_\-alloc\_\-compare}
\item 
struct \hyperlink{structdlib_1_1std__alloc__compare_3_01M1_00_01M2_00_01typename_01enable__if_3_01is__same__type_3982ed367adf685c0833f1e72cac3711f}{std\_\-alloc\_\-compare$<$ M1, M2, typename enable\_\-if$<$ is\_\-same\_\-type$<$ typename M1::mm\_\-global\_\-type, typename M2::mm\_\-global\_\-type $>$ $>$::type $>$}
\item 
struct \hyperlink{structdlib_1_1std__alloc__compare_3_01M_00_01M_00_01typename_01enable__if__c_3_01M_1_1is__stateless_01_4_1_1type_01_4}{std\_\-alloc\_\-compare$<$ M, M, typename enable\_\-if\_\-c$<$ M::is\_\-stateless $>$::type $>$}
\item 
class \hyperlink{classdlib_1_1sync__extension}{sync\_\-extension}
\item 
class \hyperlink{classdlib_1_1timeout}{timeout}
\item 
class \hyperlink{classdlib_1_1timer}{timer}
\item 
class \hyperlink{classdlib_1_1tokenizer}{tokenizer}
\item 
struct \hyperlink{structdlib_1_1unsigned__type_3_01T_00_011_01_4}{unsigned\_\-type$<$ T, 1 $>$}
\item 
struct \hyperlink{structdlib_1_1unsigned__type_3_01T_00_012_01_4}{unsigned\_\-type$<$ T, 2 $>$}
\item 
struct \hyperlink{structdlib_1_1unsigned__type_3_01T_00_014_01_4}{unsigned\_\-type$<$ T, 4 $>$}
\item 
struct \hyperlink{structdlib_1_1unsigned__type_3_01T_00_018_01_4}{unsigned\_\-type$<$ T, 8 $>$}
\item 
class \hyperlink{classdlib_1_1xml__parser}{xml\_\-parser}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef unsigned long long \hyperlink{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}{uint64}
\item 
\hypertarget{namespacedlib_a8abf353ac58a13a17a60949929cc8a49}{
typedef long long {\bfseries int64}}
\label{namespacedlib_a8abf353ac58a13a17a60949929cc8a49}

\item 
\hypertarget{namespacedlib_a609c073ecd62413ae2c606909abf62be}{
typedef unsigned short {\bfseries uint16}}
\label{namespacedlib_a609c073ecd62413ae2c606909abf62be}

\item 
\hypertarget{namespacedlib_a9279fbd8989417f50695da06d93a7907}{
typedef unsigned int {\bfseries uint32}}
\label{namespacedlib_a9279fbd8989417f50695da06d93a7907}

\item 
\hypertarget{namespacedlib_a14f6e530a2dc0eceb5c7a0bd824c397c}{
typedef unsigned char {\bfseries uint8}}
\label{namespacedlib_a14f6e530a2dc0eceb5c7a0bd824c397c}

\item 
\hypertarget{namespacedlib_a0e2c448ebe0af3cab8fa8d405eb7da4d}{
typedef short {\bfseries int16}}
\label{namespacedlib_a0e2c448ebe0af3cab8fa8d405eb7da4d}

\item 
\hypertarget{namespacedlib_a65caa9f663f1fc46f3e05469e564b130}{
typedef int {\bfseries int32}}
\label{namespacedlib_a65caa9f663f1fc46f3e05469e564b130}

\item 
\hypertarget{namespacedlib_a61ac357a576a46e2de10f08ce050e3b3}{
typedef char {\bfseries int8}}
\label{namespacedlib_a61ac357a576a46e2de10f08ce050e3b3}

\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacedlib_a3d0eb509fdefecd0e9f75bab1a0c97d9}{general\_\-return\_\-codes} \{ \par
{\bfseries TIMEOUT} =  -\/1, 
{\bfseries WOULDBLOCK} =  -\/2, 
{\bfseries OTHER\_\-ERROR} =  -\/3, 
{\bfseries SHUTDOWN} =  -\/4, 
\par
{\bfseries PORTINUSE} =  -\/5
 \}
\item 
enum {\bfseries error\_\-type} \{ \par
{\bfseries EOTHER}, 
{\bfseries EPORT\_\-IN\_\-USE}, 
{\bfseries ETIMEOUT}, 
{\bfseries ECONNECTION}, 
\par
{\bfseries ELISTENER}, 
{\bfseries ERESOLVE}, 
{\bfseries EMONITOR}, 
{\bfseries ECREATE\_\-THREAD}, 
\par
{\bfseries ECREATE\_\-MUTEX}, 
{\bfseries ECREATE\_\-SIGNALER}, 
{\bfseries EUNSPECIFIED}, 
{\bfseries EGENERAL\_\-TYPE1}, 
\par
{\bfseries EGENERAL\_\-TYPE2}, 
{\bfseries EGENERAL\_\-TYPE3}, 
{\bfseries EINVALID\_\-OPTION}, 
{\bfseries ETOO\_\-FEW\_\-ARGS}, 
\par
{\bfseries ETOO\_\-MANY\_\-ARGS}, 
{\bfseries ESOCKET}, 
{\bfseries ETHREAD}, 
{\bfseries EGUI}, 
\par
{\bfseries EFATAL}, 
{\bfseries EBROKEN\_\-ASSERT}, 
{\bfseries EIMAGE\_\-LOAD}, 
{\bfseries EDIR\_\-CREATE}, 
\par
{\bfseries EINCOMPATIBLE\_\-OPTIONS}, 
{\bfseries EMISSING\_\-REQUIRED\_\-OPTION}, 
{\bfseries EINVALID\_\-OPTION\_\-ARG}, 
{\bfseries EMULTIPLE\_\-OCCURANCES}, 
\par
{\bfseries ECONFIG\_\-READER}, 
{\bfseries EIMAGE\_\-SAVE}, 
{\bfseries ECAST\_\-TO\_\-STRING}, 
{\bfseries ESTRING\_\-CAST}, 
\par
{\bfseries EUTF8\_\-TO\_\-UTF32}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
unsigned long \hyperlink{namespacedlib_aa718d15067f15dd851a98eb1088131ae}{square\_\-root} (unsigned long value)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacedlib_af2608709700ae61f169fd4687e406267}{median} (T \&one, T \&two, T \&three)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacedlib_a7a50a190179be95c0d38aaa92960d1dc}{exchange} (T \&a, T \&b)
\item 
{\footnotesize template$<$typename T $>$ }\\\hyperlink{structboost_1_1disable__if}{disable\_\-if}$<$ \hyperlink{structdlib_1_1is__built__in__scalar__type}{is\_\-built\_\-in\_\-scalar\_\-type}$<$ T $>$, void $>$::type \hyperlink{namespacedlib_ab31aceb3894feb837313ad0add9d9294}{assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type} (T \&)
\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{namespacedlib_a36bcf970b14e81d1c300283a52d64142}{put\_\-in\_\-range} (const T \&a, const T \&b, const T \&val)
\item 
\hypertarget{namespacedlib_a34199fb0e81115d1a7eec041d0f2edef}{
double {\bfseries put\_\-in\_\-range} (const double \&a, const double \&b, const double \&val)}
\label{namespacedlib_a34199fb0e81115d1a7eec041d0f2edef}

\item 
\hypertarget{namespacedlib_a664fced8a504dcda3711a21258481150}{
std::ostream \& {\bfseries operator$<$$<$} (std::ostream \&out, const \hyperlink{classdlib_1_1assignment}{assignment} \&a)}
\label{namespacedlib_a664fced8a504dcda3711a21258481150}

\item 
\hypertarget{namespacedlib_a7afaf7852d23c95c6145909611737d13}{
void {\bfseries swap} (\hyperlink{classdlib_1_1assignment}{assignment} \&a, \hyperlink{classdlib_1_1assignment}{assignment} \&b)}
\label{namespacedlib_a7afaf7852d23c95c6145909611737d13}

\item 
\hypertarget{namespacedlib_af347d1e8f9880bb7f1f1c3a42ea60df3}{
void {\bfseries swap} (\hyperlink{classdlib_1_1joint__probability__table}{joint\_\-probability\_\-table} \&a, \hyperlink{classdlib_1_1joint__probability__table}{joint\_\-probability\_\-table} \&b)}
\label{namespacedlib_af347d1e8f9880bb7f1f1c3a42ea60df3}

\item 
\hypertarget{namespacedlib_a8b27c914488b4014e5719374d7318d9f}{
void {\bfseries swap} (\hyperlink{classdlib_1_1conditional__probability__table}{conditional\_\-probability\_\-table} \&a, \hyperlink{classdlib_1_1conditional__probability__table}{conditional\_\-probability\_\-table} \&b)}
\label{namespacedlib_a8b27c914488b4014e5719374d7318d9f}

\item 
\hypertarget{namespacedlib_a7bcc46f1847648e253d66802ef05272f}{
void {\bfseries swap} (\hyperlink{classdlib_1_1bayes__node}{bayes\_\-node} \&a, \hyperlink{classdlib_1_1bayes__node}{bayes\_\-node} \&b)}
\label{namespacedlib_a7bcc46f1847648e253d66802ef05272f}

\item 
\hypertarget{namespacedlib_a61b07f424fd7415b61689a8fbdda9857}{
void {\bfseries swap} (\hyperlink{classdlib_1_1bayesian__network__join__tree}{bayesian\_\-network\_\-join\_\-tree} \&a, \hyperlink{classdlib_1_1bayesian__network__join__tree}{bayesian\_\-network\_\-join\_\-tree} \&b)}
\label{namespacedlib_a61b07f424fd7415b61689a8fbdda9857}

\item 
\hypertarget{namespacedlib_a8d76ef041038ff39aa6660f4764ea60d}{
{\footnotesize template$<$typename P1 , typename P2 $>$ }\\void {\bfseries assign\_\-pixel} (P1 \&dest, const P2 \&src)}
\label{namespacedlib_a8d76ef041038ff39aa6660f4764ea60d}

\item 
{\footnotesize template$<$typename P $>$ }\\void \hyperlink{namespacedlib_a88c00fa9d7ea718f6198c72451378f2a}{assign\_\-pixel} (P \&dest, const int src)
\item 
{\footnotesize template$<$typename P $>$ }\\void \hyperlink{namespacedlib_a5756e98c19859a24eb42d6b906808095}{assign\_\-pixel} (P \&dest, const long src)
\item 
{\footnotesize template$<$typename P $>$ }\\unsigned long \hyperlink{namespacedlib_acadbad5cd1cbaf9f188eb56b518a0f01}{get\_\-pixel\_\-intensity} (const P \&src)
\item 
{\footnotesize template$<$typename P $>$ }\\void \hyperlink{namespacedlib_a3b9a3281788e2c68adbe5e81265aaeb2}{assign\_\-pixel\_\-intensity} (P \&dest, const unsigned long new\_\-intensity)
\item 
void \hyperlink{namespacedlib_ac78b72e65600a0d25ac3224539794fc2}{serialize} (const \hyperlink{structdlib_1_1rgb__pixel}{rgb\_\-pixel} \&item, std::ostream \&out)
\item 
void \hyperlink{namespacedlib_a5e5ead1e1179ca255a628e46a55d12ce}{deserialize} (\hyperlink{structdlib_1_1rgb__pixel}{rgb\_\-pixel} \&item, std::istream \&in)
\item 
void \hyperlink{namespacedlib_aefd5ce982b258dc62d2c4a657278a492}{serialize} (const \hyperlink{structdlib_1_1bgr__pixel}{bgr\_\-pixel} \&item, std::ostream \&out)
\item 
void \hyperlink{namespacedlib_a2ffefe1102a7c709e26a23b4f2c7668c}{deserialize} (\hyperlink{structdlib_1_1bgr__pixel}{bgr\_\-pixel} \&item, std::istream \&in)
\item 
void \hyperlink{namespacedlib_abbbd5224f9387eef940579cdf3fd4a13}{serialize} (const \hyperlink{structdlib_1_1rgb__alpha__pixel}{rgb\_\-alpha\_\-pixel} \&item, std::ostream \&out)
\item 
void \hyperlink{namespacedlib_a59df13454703d695429ac5af04c8cb35}{deserialize} (\hyperlink{structdlib_1_1rgb__alpha__pixel}{rgb\_\-alpha\_\-pixel} \&item, std::istream \&in)
\item 
void \hyperlink{namespacedlib_add718e65e3023a2abd8eb04200e81b52}{serialize} (const \hyperlink{structdlib_1_1hsi__pixel}{hsi\_\-pixel} \&item, std::ostream \&out)
\item 
void \hyperlink{namespacedlib_a5291c6d8fcf1bd624eaa7f908ea137bf}{deserialize} (\hyperlink{structdlib_1_1hsi__pixel}{hsi\_\-pixel} \&item, std::istream \&in)
\item 
\hypertarget{namespacedlib_a21491eceab973e1bd6efb6730dfdc890}{
{\footnotesize template$<$typename P1 $>$ }\\void {\bfseries assign\_\-pixel} (P1 \&dest, const int src)}
\label{namespacedlib_a21491eceab973e1bd6efb6730dfdc890}

\item 
\hypertarget{namespacedlib_a5f5a56be49a2fdda3449976b8234ec72}{
{\footnotesize template$<$typename P1 $>$ }\\void {\bfseries assign\_\-pixel} (P1 \&dest, const long src)}
\label{namespacedlib_a5f5a56be49a2fdda3449976b8234ec72}

\item 
\hypertarget{namespacedlib_a93ad558cb34ff5f74d81a831b4a71bc3}{
{\footnotesize template$<$typename P $>$ }\\\hyperlink{structboost_1_1enable__if__c}{enable\_\-if\_\-c}$<$ pixel\_\-traits$<$ P $>$::grayscale $>$::type {\bfseries assign\_\-pixel\_\-intensity\_\-helper} (P \&dest, const unsigned long \&new\_\-intensity)}
\label{namespacedlib_a93ad558cb34ff5f74d81a831b4a71bc3}

\item 
\hypertarget{namespacedlib_a3f6926b9bee52d60483f299adc4bf25e}{
{\footnotesize template$<$typename P $>$ }\\\hyperlink{structboost_1_1enable__if__c}{enable\_\-if\_\-c}$<$ pixel\_\-traits$<$ P $>$::grayscale, unsigned long $>$::type {\bfseries get\_\-pixel\_\-intensity\_\-helper} (const P \&src)}
\label{namespacedlib_a3f6926b9bee52d60483f299adc4bf25e}

\item 
\hypertarget{namespacedlib_a0de1a663136d3a8c409bd1115252defe}{
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries serialize\_\-floating\_\-point} (const T \&item, std::ostream \&out)}
\label{namespacedlib_a0de1a663136d3a8c409bd1115252defe}

\item 
\hypertarget{namespacedlib_a62cc4e230a3ceead473b81ab10cc92d9}{
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries deserialize\_\-floating\_\-point} (T \&item, std::istream \&in)}
\label{namespacedlib_a62cc4e230a3ceead473b81ab10cc92d9}

\item 
\hypertarget{namespacedlib_a60d8087da7a2b5ceee84fea3b9765fe8}{
void {\bfseries serialize} (const float \&item, std::ostream \&out)}
\label{namespacedlib_a60d8087da7a2b5ceee84fea3b9765fe8}

\item 
\hypertarget{namespacedlib_a633c78678b1b8e042930c3bcdc3ddf14}{
void {\bfseries deserialize} (float \&item, std::istream \&in)}
\label{namespacedlib_a633c78678b1b8e042930c3bcdc3ddf14}

\item 
\hypertarget{namespacedlib_aeda8e7a61ab291286b5ea316e8fc21c8}{
void {\bfseries serialize} (const double \&item, std::ostream \&out)}
\label{namespacedlib_aeda8e7a61ab291286b5ea316e8fc21c8}

\item 
\hypertarget{namespacedlib_a62b71c98cbea2ca79cae9f64e7cc8953}{
void {\bfseries deserialize} (double \&item, std::istream \&in)}
\label{namespacedlib_a62b71c98cbea2ca79cae9f64e7cc8953}

\item 
\hypertarget{namespacedlib_ad55b3e391e2ed4a3470170eadc37cf2c}{
void {\bfseries serialize} (const long double \&item, std::ostream \&out)}
\label{namespacedlib_ad55b3e391e2ed4a3470170eadc37cf2c}

\item 
\hypertarget{namespacedlib_aee37ef95181adb0209407e5be1f61503}{
void {\bfseries deserialize} (long double \&item, std::istream \&in)}
\label{namespacedlib_aee37ef95181adb0209407e5be1f61503}

\item 
\hypertarget{namespacedlib_a83a85a683fa3b9a5bc9cf742bf8bdf02}{
{\footnotesize template$<$typename domain , typename range , typename compare , typename alloc $>$ }\\void {\bfseries serialize} (const std::map$<$ domain, range, compare, alloc $>$ \&item, std::ostream \&out)}
\label{namespacedlib_a83a85a683fa3b9a5bc9cf742bf8bdf02}

\item 
\hypertarget{namespacedlib_a0b1b60f9c8429e5ab81c50994896dcf9}{
{\footnotesize template$<$typename domain , typename range , typename compare , typename alloc $>$ }\\void {\bfseries deserialize} (std::map$<$ domain, range, compare, alloc $>$ \&item, std::istream \&in)}
\label{namespacedlib_a0b1b60f9c8429e5ab81c50994896dcf9}

\item 
\hypertarget{namespacedlib_a5a7213bb6f1e0dcd5d2fc84ac6b29ff5}{
{\footnotesize template$<$typename T , typename alloc $>$ }\\void {\bfseries serialize} (const std::vector$<$ T, alloc $>$ \&item, std::ostream \&out)}
\label{namespacedlib_a5a7213bb6f1e0dcd5d2fc84ac6b29ff5}

\item 
\hypertarget{namespacedlib_a57405739e762674afe117eed2ce6a55f}{
{\footnotesize template$<$typename T , typename alloc $>$ }\\void {\bfseries deserialize} (std::vector$<$ T $>$ \&item, std::istream \&in)}
\label{namespacedlib_a57405739e762674afe117eed2ce6a55f}

\item 
\hypertarget{namespacedlib_a26ecdaff21c62bd613f3e60e2f957cdf}{
void {\bfseries serialize} (const std::string \&item, std::ostream \&out)}
\label{namespacedlib_a26ecdaff21c62bd613f3e60e2f957cdf}

\item 
\hypertarget{namespacedlib_a3d181320a2ea2281013627f0dd45f78a}{
void {\bfseries deserialize} (std::string \&item, std::istream \&in)}
\label{namespacedlib_a3d181320a2ea2281013627f0dd45f78a}

\item 
\hypertarget{namespacedlib_ae375af950cbedb6ea620a360dbbde14c}{
{\footnotesize template$<$typename T $>$ }\\void {\bfseries serialize} (const enumerable$<$ T $>$ \&item, std::ostream \&out)}
\label{namespacedlib_ae375af950cbedb6ea620a360dbbde14c}

\item 
\hypertarget{namespacedlib_aabd16ce881f3b10e3114a9ee4d36eb53}{
{\footnotesize template$<$typename domain , typename range $>$ }\\void {\bfseries serialize} (const map\_\-pair$<$ domain, range $>$ \&item, std::ostream \&out)}
\label{namespacedlib_aabd16ce881f3b10e3114a9ee4d36eb53}

\item 
\hypertarget{namespacedlib_a30ba61778b439901187e9861f4697ea4}{
{\footnotesize template$<$typename T , size\_\-t length$>$ }\\void {\bfseries serialize} (const T(\&\hyperlink{classdlib_1_1array}{array})\mbox{[}length\mbox{]}, std::ostream \&out)}
\label{namespacedlib_a30ba61778b439901187e9861f4697ea4}

\item 
\hypertarget{namespacedlib_a2d2257002446a71b34e2ca9ee8951056}{
{\footnotesize template$<$typename T , size\_\-t length$>$ }\\void {\bfseries deserialize} (T(\&\hyperlink{classdlib_1_1array}{array})\mbox{[}length\mbox{]}, std::istream \&in)}
\label{namespacedlib_a2d2257002446a71b34e2ca9ee8951056}

\item 
\hypertarget{namespacedlib_a76bce1d897763e63ec3e3cae29bfe3e3}{
void {\bfseries serialize} (bool item, std::ostream \&out)}
\label{namespacedlib_a76bce1d897763e63ec3e3cae29bfe3e3}

\item 
\hypertarget{namespacedlib_a088fe6787c9d6685e26a1d44564fd76c}{
void {\bfseries deserialize} (bool \&item, std::istream \&in)}
\label{namespacedlib_a088fe6787c9d6685e26a1d44564fd76c}

\item 
\hypertarget{namespacedlib_aa14e6433b45994673acf66ad05679460}{
{\footnotesize template$<$typename T , typename alloc $>$ }\\void {\bfseries deserialize} (std::vector$<$ T, alloc $>$ \&item, std::istream \&in)}
\label{namespacedlib_aa14e6433b45994673acf66ad05679460}

\item 
\hypertarget{namespacedlib_aba03d630ebab1399951ff2efc53258fe}{
void {\bfseries serialize} (const std::wstring \&item, std::ostream \&out)}
\label{namespacedlib_aba03d630ebab1399951ff2efc53258fe}

\item 
\hypertarget{namespacedlib_a6587fb43c37bb5891a1680271e5d2db6}{
void {\bfseries deserialize} (std::wstring \&item, std::istream \&in)}
\label{namespacedlib_a6587fb43c37bb5891a1680271e5d2db6}

\item 
\hypertarget{namespacedlib_acb3cb215c97a5b5cea0e6224f90ef869}{
void {\bfseries serialize} (const ustring \&item, std::ostream \&out)}
\label{namespacedlib_acb3cb215c97a5b5cea0e6224f90ef869}

\item 
\hypertarget{namespacedlib_a59ca48e244880b2dee83ccd21a9ff8eb}{
void {\bfseries deserialize} (ustring \&item, std::istream \&in)}
\label{namespacedlib_a59ca48e244880b2dee83ccd21a9ff8eb}

\item 
\hypertarget{namespacedlib_affd2021d7bd2c3b01fd232c92b0cb82a}{
{\footnotesize template$<$typename T $>$ }\\void {\bfseries serialize} (const std::complex$<$ T $>$ \&item, std::ostream \&out)}
\label{namespacedlib_affd2021d7bd2c3b01fd232c92b0cb82a}

\item 
\hypertarget{namespacedlib_a3440b6f4db4ad716e217da64cadbb14d}{
{\footnotesize template$<$typename T $>$ }\\void {\bfseries deserialize} (std::complex$<$ T $>$ \&item, std::istream \&in)}
\label{namespacedlib_a3440b6f4db4ad716e217da64cadbb14d}

\item 
\hypertarget{namespacedlib_a500f78eac0d057fd1023a6bb025ce918}{
{\footnotesize template$<$typename T , typename compare $>$ }\\void {\bfseries qsort\_\-array} (T \&\hyperlink{classdlib_1_1array}{array}, unsigned long left, unsigned long right, const compare \&comp)}
\label{namespacedlib_a500f78eac0d057fd1023a6bb025ce918}

\item 
{\footnotesize template$<$typename T , typename compare $>$ }\\void \hyperlink{namespacedlib_ad2483eaef67b51922017370294317395}{hsort\_\-array} (T \&\hyperlink{classdlib_1_1array}{array}, unsigned long left, unsigned long right, const compare \&comp)
\item 
{\footnotesize template$<$typename T , typename compare $>$ }\\void \hyperlink{namespacedlib_a67b8e8c3f84cc73d4335f36131d6dd3f}{isort\_\-array} (T \&\hyperlink{classdlib_1_1array}{array}, unsigned long left, unsigned long right, const compare \&comp)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacedlib_a603b4c76cedf8bff5975b76817f27eaa}{qsort\_\-array} (T \&\hyperlink{classdlib_1_1array}{array}, unsigned long left, unsigned long right)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacedlib_ad6abbf5d4ec2109706476146835059b7}{hsort\_\-array} (T \&\hyperlink{classdlib_1_1array}{array}, unsigned long left, unsigned long right)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacedlib_af630f6e36af2fed569135ae72246e016}{isort\_\-array} (T \&\hyperlink{classdlib_1_1array}{array}, unsigned long left, unsigned long right)
\item 
\hypertarget{namespacedlib_a963489c2ce136f1924ae92bf47ab12a7}{
const std::string {\bfseries get\_\-stack\_\-trace} ()}
\label{namespacedlib_a963489c2ce136f1924ae92bf47ab12a7}

\item 
\hypertarget{namespacedlib_ad04e79a06dc35940470c2d4422051d21}{
{\footnotesize template$<$typename T1 , typename M1 , typename T2 , typename M2 $>$ }\\bool {\bfseries operator==} (const \hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}$<$ T1, M1 $>$ \&, const \hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}$<$ T2, M2 $>$ \&)  throw ()}
\label{namespacedlib_ad04e79a06dc35940470c2d4422051d21}

\item 
\hypertarget{namespacedlib_a5419d341c5a35f9fa10c05cc5291f851}{
{\footnotesize template$<$typename T1 , typename M1 , typename T2 , typename M2 $>$ }\\bool {\bfseries operator!=} (const \hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}$<$ T1, M1 $>$ \&, const \hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}$<$ T2, M2 $>$ \&)  throw ()}
\label{namespacedlib_a5419d341c5a35f9fa10c05cc5291f851}

\item 
\hypertarget{namespacedlib_acf38fa94722837a9a6c027cdedb3d95c}{
{\footnotesize template$<$typename T , typename M $>$ }\\void {\bfseries swap} (\hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}$<$ T, M $>$ \&a, \hyperlink{classdlib_1_1std__allocator}{std\_\-allocator}$<$ T, M $>$ \&b)}
\label{namespacedlib_acf38fa94722837a9a6c027cdedb3d95c}

\item 
\hypertarget{namespacedlib_aeb7adb34b3185802d0bb88a1cdc74e0a}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(uint8)==1)}
\label{namespacedlib_aeb7adb34b3185802d0bb88a1cdc74e0a}

\item 
\hypertarget{namespacedlib_a35a780750c26bf4dbdf1c35fe1a56c3e}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(uint16)==2)}
\label{namespacedlib_a35a780750c26bf4dbdf1c35fe1a56c3e}

\item 
\hypertarget{namespacedlib_acedb24147b035ef793368d07f6e442a9}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(uint32)==4)}
\label{namespacedlib_acedb24147b035ef793368d07f6e442a9}

\item 
\hypertarget{namespacedlib_acfbff5c3e08b2c288cb019376894949a}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(\hyperlink{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}{uint64})==8)}
\label{namespacedlib_acfbff5c3e08b2c288cb019376894949a}

\item 
\hypertarget{namespacedlib_aec561058332d9a7ccc288ff03c0a3452}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(int8)==1)}
\label{namespacedlib_aec561058332d9a7ccc288ff03c0a3452}

\item 
\hypertarget{namespacedlib_abf49734f8889a0230d2167d84acc3987}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(int16)==2)}
\label{namespacedlib_abf49734f8889a0230d2167d84acc3987}

\item 
\hypertarget{namespacedlib_a35f54002263fc38d786ef9c76668f950}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(int32)==4)}
\label{namespacedlib_a35f54002263fc38d786ef9c76668f950}

\item 
\hypertarget{namespacedlib_a66818c36792273096fbf0e1168764bd1}{
{\bfseries COMPILE\_\-TIME\_\-ASSERT} (sizeof(int64)==8)}
\label{namespacedlib_a66818c36792273096fbf0e1168764bd1}

\item 
{\footnotesize template$<$typename T , typename U $>$ }\\T \hyperlink{namespacedlib_a87847cba5edee8c23c0970bbe19fa3ce}{zero\_\-extend\_\-cast} (const U val)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hypertarget{namespacedlib_a7fb617da1a86ef17870d75dd52a8112a}{
union \hyperlink{uniondlib_1_1mem__block}{dlib::mem\_\-block} {\bfseries mem}}
\label{namespacedlib_a7fb617da1a86ef17870d75dd52a8112a}

\item 
\hypertarget{namespacedlib_aaf90d7d28af819b88c07f7720ba126cb}{
void $\ast$const {\bfseries data}}
\label{namespacedlib_aaf90d7d28af819b88c07f7720ba126cb}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
requires
\begin{DoxyItemize}
\item charT == char or wchar\_\-t
\item str == a string or character literal ensures
\item returns the literal in the form of a charT type literal. !
\end{DoxyItemize}

There are two global functions in the \hyperlink{namespacedlib}{dlib} namespace that provide serialization and deserialization support. Their signatures and specifications are as follows:

void serialize ( const serializable\_\-type\& item, std::ostream\& out ); /!$\ast$ ensures
\begin{DoxyItemize}
\item writes the state of item to the output stream out
\item if (serializable\_\-type implements the enumerable interface) then
\begin{DoxyItemize}
\item item.at\_\-start() == true throws
\end{DoxyItemize}
\item \hyperlink{classdlib_1_1serialization__error}{serialization\_\-error} This exception is thrown if there is some problem which prevents us from successfully writing item to the output stream.
\item any other exception !/
\end{DoxyItemize}

void deserialize ( serializable\_\-type\& item, std::istream\& in ); /!$\ast$ ensures
\begin{DoxyItemize}
\item item == a deserialized copy of the serializable\_\-type that was in the input stream in.
\item if (serializable\_\-type implements the enumerable interface) then
\begin{DoxyItemize}
\item item.at\_\-start() == true throws
\end{DoxyItemize}
\item \hyperlink{classdlib_1_1serialization__error}{serialization\_\-error} This exception is thrown if there is some problem which prevents us from successfully deserializing item from the input stream. If this exception is thrown then item will have an initial value for its type.
\item any other exception !/
\end{DoxyItemize}

This file provides serialization support to the following object types:
\begin{DoxyItemize}
\item The C++ base types (NOT including pointer types)
\item std::string
\item std::wstring
\item std::vector
\item std::map
\item std::complex
\item \hyperlink{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}{dlib::uint64}
\item enumerable$<$T$>$ where T is a serializable type
\item map\_\-pair$<$D,R$>$ where D and R are both serializable types.
\item C style arrays of serializable types
\end{DoxyItemize}

This file provides deserialization support to the following object types:
\begin{DoxyItemize}
\item The C++ base types (NOT including pointer types)
\item std::string
\item std::wstring
\item std::vector
\item std::map
\item std::complex
\item \hyperlink{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}{dlib::uint64}
\item C style arrays of serializable types
\end{DoxyItemize}

Support for deserialization of objects which implement the enumerable or map\_\-pair interfaces is the responsibility of those objects.

Note that you can deserialize an integer value to any integral type (except for a char type) if its value will fit into the target integer type. I.e. the types short, int, long, unsigned short, unsigned int, unsigned long, and \hyperlink{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}{dlib::uint64} can all receive serialized data from each other so long as the actual serizlied value fits within the receiving integral type's range.

Also note that for any container to be serializable the type of object it contains must be serializable.

FILE STREAMS If you are serializing to and from file streams it is important to remember to \hyperlink{classdlib_1_1set}{set} the file streams to binary mode using the std::ios::binary flag.

INTEGRAL SERIALIZATION FORMAT All C++ integral types (except the char types) are serialized to the following format: The first byte is a control byte. It tells you if the serialized number is positive or negative and also tells you how many of the following bytes are part of the number. The absolute value of the number is stored in little endian byte order and follows the control byte.

The control byte: The high order bit of the control byte is a flag that tells you if the encoded number is negative or not. It is \hyperlink{classdlib_1_1set}{set} to 1 when the number is negative and 0 otherwise. The 4 low order bits of the control byte represent an unsigned number and tells you how many of the following bytes are part of the encoded number.

! 

\subsection{Typedef Documentation}
\hypertarget{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}{
\index{dlib@{dlib}!uint64@{uint64}}
\index{uint64@{uint64}!dlib@{dlib}}
\subsubsection[{uint64}]{\setlength{\rightskip}{0pt plus 5cm}typedef unsigned long long {\bf dlib::uint64}}}
\label{namespacedlib_a61113f8b6b3e4ccb66deca9355c8f65d}
uint64 is a typedef for an unsigned integer that is exactly 64 bits wide. uint32 is a typedef for an unsigned integer that is exactly 32 bits wide. uint16 is a typedef for an unsigned integer that is exactly 16 bits wide. uint8 is a typedef for an unsigned integer that is exactly 8 bits wide.

int64 is a typedef for an integer that is exactly 64 bits wide. int32 is a typedef for an integer that is exactly 32 bits wide. int16 is a typedef for an integer that is exactly 16 bits wide. int8 is a typedef for an integer that is exactly 8 bits wide. ! 

\subsection{Enumeration Type Documentation}
\hypertarget{namespacedlib_a3d0eb509fdefecd0e9f75bab1a0c97d9}{
\index{dlib@{dlib}!general\_\-return\_\-codes@{general\_\-return\_\-codes}}
\index{general\_\-return\_\-codes@{general\_\-return\_\-codes}!dlib@{dlib}}
\subsubsection[{general\_\-return\_\-codes}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf dlib::general\_\-return\_\-codes}}}
\label{namespacedlib_a3d0eb509fdefecd0e9f75bab1a0c97d9}
Here is where I define my return codes. It is important that they all be $<$ 0. ! 

\subsection{Function Documentation}
\hypertarget{namespacedlib_a5756e98c19859a24eb42d6b906808095}{
\index{dlib@{dlib}!assign\_\-pixel@{assign\_\-pixel}}
\index{assign\_\-pixel@{assign\_\-pixel}!dlib@{dlib}}
\subsubsection[{assign\_\-pixel}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ void dlib::assign\_\-pixel (P \& {\em dest}, \/  const long {\em src})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a5756e98c19859a24eb42d6b906808095}
requires
\begin{DoxyItemize}
\item pixel\_\-traits
\end{DoxyItemize}

must be defined ensures
\begin{DoxyItemize}
\item performs assign\_\-pixel(dest, static\_\-cast$<$unsigned long$>$(max(0,src))) ! 
\end{DoxyItemize}\hypertarget{namespacedlib_a88c00fa9d7ea718f6198c72451378f2a}{
\index{dlib@{dlib}!assign\_\-pixel@{assign\_\-pixel}}
\index{assign\_\-pixel@{assign\_\-pixel}!dlib@{dlib}}
\subsubsection[{assign\_\-pixel}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ void dlib::assign\_\-pixel (P \& {\em dest}, \/  const int {\em src})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a88c00fa9d7ea718f6198c72451378f2a}
requires
\begin{DoxyItemize}
\item pixel\_\-traits$<$P1$>$ must be defined
\item pixel\_\-traits$<$P2$>$ must be defined ensures
\item if (P1 and P2 are the same type of pixel) then
\begin{DoxyItemize}
\item simply coppies the value of src into dest. In other words, dest will be identical to src after this function returns.
\end{DoxyItemize}
\item else if (P1 and P2 are not the same type of pixel) then
\begin{DoxyItemize}
\item assigns pixel src to pixel dest and does any necessary color space conversions.
\item When converting from a grayscale color space with more than 255 values the pixel intensity is saturated at pixel\_\-traits$<$P1$>$::max().
\item if (the dest pixel has an alpha channel and the src pixel doesn't) then
\begin{DoxyItemize}
\item dest.alpha == 255
\end{DoxyItemize}
\item else if (the src pixel has an alpha channel but the dest pixel doesn't) then
\begin{DoxyItemize}
\item dest == the original dest value blended with the src value according to the alpha channel in src. (i.e. dest == src$\ast$(alpha/255) + dest$\ast$(1-\/alpha/255)) ! 
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{namespacedlib_a3b9a3281788e2c68adbe5e81265aaeb2}{
\index{dlib@{dlib}!assign\_\-pixel\_\-intensity@{assign\_\-pixel\_\-intensity}}
\index{assign\_\-pixel\_\-intensity@{assign\_\-pixel\_\-intensity}!dlib@{dlib}}
\subsubsection[{assign\_\-pixel\_\-intensity}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ void dlib::assign\_\-pixel\_\-intensity (P \& {\em dest}, \/  const unsigned long {\em new\_\-intensity})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a3b9a3281788e2c68adbe5e81265aaeb2}
requires
\begin{DoxyItemize}
\item pixel\_\-traits
\end{DoxyItemize}

must be defined ensures
\begin{DoxyItemize}
\item if (pixel\_\-traits$<$P$>$::grayscale == true) then
\begin{DoxyItemize}
\item returns src
\end{DoxyItemize}
\item else
\begin{DoxyItemize}
\item converts src to the HSI color space and returns the intensity ! 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{namespacedlib_ab31aceb3894feb837313ad0add9d9294}{
\index{dlib@{dlib}!assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type@{assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type}}
\index{assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type@{assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type}!dlib@{dlib}}
\subsubsection[{assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ {\bf enable\_\-if}$<$ {\bf is\_\-built\_\-in\_\-scalar\_\-type}$<$ T $>$, void $>$::type dlib::assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type (T \& {\em a})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_ab31aceb3894feb837313ad0add9d9294}
A assign\_\-zero\_\-if\_\-built\_\-in\_\-scalar\_\-type

This function assigns its argument the value of 0 if it is a built in scalar type according to the is\_\-built\_\-in\_\-scalar\_\-type$<$$>$ template. If it isn't a built in scalar type then it does nothing. ! \hypertarget{namespacedlib_a5291c6d8fcf1bd624eaa7f908ea137bf}{
\index{dlib@{dlib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!dlib@{dlib}}
\subsubsection[{deserialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::deserialize (hsi\_\-pixel \& {\em item}, \/  std::istream \& {\em in})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a5291c6d8fcf1bd624eaa7f908ea137bf}
provides serialization support for the \hyperlink{structdlib_1_1hsi__pixel}{hsi\_\-pixel} struct ! \hypertarget{namespacedlib_a59df13454703d695429ac5af04c8cb35}{
\index{dlib@{dlib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!dlib@{dlib}}
\subsubsection[{deserialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::deserialize (rgb\_\-alpha\_\-pixel \& {\em item}, \/  std::istream \& {\em in})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a59df13454703d695429ac5af04c8cb35}
provides serialization support for the \hyperlink{structdlib_1_1rgb__alpha__pixel}{rgb\_\-alpha\_\-pixel} struct ! \hypertarget{namespacedlib_a2ffefe1102a7c709e26a23b4f2c7668c}{
\index{dlib@{dlib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!dlib@{dlib}}
\subsubsection[{deserialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::deserialize (bgr\_\-pixel \& {\em item}, \/  std::istream \& {\em in})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a2ffefe1102a7c709e26a23b4f2c7668c}
provides serialization support for the \hyperlink{structdlib_1_1bgr__pixel}{bgr\_\-pixel} struct ! \hypertarget{namespacedlib_a5e5ead1e1179ca255a628e46a55d12ce}{
\index{dlib@{dlib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!dlib@{dlib}}
\subsubsection[{deserialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::deserialize (rgb\_\-pixel \& {\em item}, \/  std::istream \& {\em in})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a5e5ead1e1179ca255a628e46a55d12ce}
provides serialization support for the \hyperlink{structdlib_1_1rgb__pixel}{rgb\_\-pixel} struct ! \hypertarget{namespacedlib_a7a50a190179be95c0d38aaa92960d1dc}{
\index{dlib@{dlib}!exchange@{exchange}}
\index{exchange@{exchange}!dlib@{dlib}}
\subsubsection[{exchange}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void dlib::exchange (T \& {\em a}, \/  T \& {\em b})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a7a50a190179be95c0d38aaa92960d1dc}
This function does the exact same thing that global swap does and it does it by just calling swap. But a lot of compilers have problems doing a Koenig Lookup and the fact that this has a different name (global swap has the same name as the member functions called swap) makes them compile right.

So this is a workaround but not too ugly of one. But hopefully I get get rid of this in a few years. So this function is alredy deprecated.

This also means you should NOT use this function in your own code unless you have to support an old buggy compiler that benefits from this hack. ! \hypertarget{namespacedlib_acadbad5cd1cbaf9f188eb56b518a0f01}{
\index{dlib@{dlib}!get\_\-pixel\_\-intensity@{get\_\-pixel\_\-intensity}}
\index{get\_\-pixel\_\-intensity@{get\_\-pixel\_\-intensity}!dlib@{dlib}}
\subsubsection[{get\_\-pixel\_\-intensity}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ unsigned long dlib::get\_\-pixel\_\-intensity (const P \& {\em src})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_acadbad5cd1cbaf9f188eb56b518a0f01}
requires
\begin{DoxyItemize}
\item pixel\_\-traits
\end{DoxyItemize}

must be defined ensures
\begin{DoxyItemize}
\item performs assign\_\-pixel(dest, static\_\-cast$<$unsigned long$>$(max(0,src))) ! 
\end{DoxyItemize}\hypertarget{namespacedlib_ad6abbf5d4ec2109706476146835059b7}{
\index{dlib@{dlib}!hsort\_\-array@{hsort\_\-array}}
\index{hsort\_\-array@{hsort\_\-array}!dlib@{dlib}}
\subsubsection[{hsort\_\-array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void dlib::hsort\_\-array (T \& {\em array}, \/  unsigned long {\em left}, \/  unsigned long {\em right})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_ad6abbf5d4ec2109706476146835059b7}
requires
\begin{DoxyItemize}
\item T implements operator\mbox{[}\mbox{]}
\item the items in \hyperlink{classdlib_1_1array}{array} must be comparable by std::less
\item the items in \hyperlink{classdlib_1_1array}{array} must be swappable by a global swap()
\item left and right are within the bounds of \hyperlink{classdlib_1_1array}{array} i.e. \hyperlink{classdlib_1_1array}{array}\mbox{[}left\mbox{]} and \hyperlink{classdlib_1_1array}{array}\mbox{[}right\mbox{]} are valid elements
\item left $<$= right ensures
\item for all elements in array between and including left and right the ith element is $<$ the i+1 element
\item sorts using a quick sort algorithm ! 
\end{DoxyItemize}\hypertarget{namespacedlib_ad2483eaef67b51922017370294317395}{
\index{dlib@{dlib}!hsort\_\-array@{hsort\_\-array}}
\index{hsort\_\-array@{hsort\_\-array}!dlib@{dlib}}
\subsubsection[{hsort\_\-array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename compare $>$ void dlib::hsort\_\-array (T \& {\em array}, \/  unsigned long {\em left}, \/  unsigned long {\em right}, \/  const compare \& {\em comp})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_ad2483eaef67b51922017370294317395}
requires
\begin{DoxyItemize}
\item T implements operator\mbox{[}\mbox{]}
\item the items in \hyperlink{classdlib_1_1array}{array} must be comparable by comp where comp is a function object with the same syntax as std::less$<$$>$
\item the items in \hyperlink{classdlib_1_1array}{array} must be swappable by a global swap()
\item left and right are within the bounds of \hyperlink{classdlib_1_1array}{array} i.e. \hyperlink{classdlib_1_1array}{array}\mbox{[}left\mbox{]} and \hyperlink{classdlib_1_1array}{array}\mbox{[}right\mbox{]} are valid elements
\item left $<$= right ensures
\item for all elements in array between and including left and right the ith element is $<$ the i+1 element
\item sorts using a quick sort algorithm ! 
\end{DoxyItemize}\hypertarget{namespacedlib_af630f6e36af2fed569135ae72246e016}{
\index{dlib@{dlib}!isort\_\-array@{isort\_\-array}}
\index{isort\_\-array@{isort\_\-array}!dlib@{dlib}}
\subsubsection[{isort\_\-array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void dlib::isort\_\-array (T \& {\em array}, \/  unsigned long {\em left}, \/  unsigned long {\em right})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_af630f6e36af2fed569135ae72246e016}
requires
\begin{DoxyItemize}
\item T implements operator\mbox{[}\mbox{]}
\item the items in \hyperlink{classdlib_1_1array}{array} must be comparable by std::less
\item the items in \hyperlink{classdlib_1_1array}{array} must be swappable by a global swap()
\item left and right are within the bounds of \hyperlink{classdlib_1_1array}{array} i.e. \hyperlink{classdlib_1_1array}{array}\mbox{[}left\mbox{]} and \hyperlink{classdlib_1_1array}{array}\mbox{[}right\mbox{]} are valid elements
\item left $<$= right ensures
\item for all elements in array between and including left and right the ith element is $<$ the i+1 element
\item sorts using a heapsort algorithm ! 
\end{DoxyItemize}\hypertarget{namespacedlib_a67b8e8c3f84cc73d4335f36131d6dd3f}{
\index{dlib@{dlib}!isort\_\-array@{isort\_\-array}}
\index{isort\_\-array@{isort\_\-array}!dlib@{dlib}}
\subsubsection[{isort\_\-array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename compare $>$ void dlib::isort\_\-array (T \& {\em array}, \/  unsigned long {\em left}, \/  unsigned long {\em right}, \/  const compare \& {\em comp})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a67b8e8c3f84cc73d4335f36131d6dd3f}
requires
\begin{DoxyItemize}
\item T implements operator\mbox{[}\mbox{]}
\item the items in \hyperlink{classdlib_1_1array}{array} must be comparable by comp where comp is a function object with the same syntax as std::less$<$$>$
\item the items in \hyperlink{classdlib_1_1array}{array} must be swappable by a global swap()
\item left and right are within the bounds of \hyperlink{classdlib_1_1array}{array} i.e. \hyperlink{classdlib_1_1array}{array}\mbox{[}left\mbox{]} and \hyperlink{classdlib_1_1array}{array}\mbox{[}right\mbox{]} are valid elements
\item left $<$= right ensures
\item for all elements in array between and including left and right the ith element is $<$ the i+1 element
\item sorts using a heapsort algorithm ! 
\end{DoxyItemize}\hypertarget{namespacedlib_af2608709700ae61f169fd4687e406267}{
\index{dlib@{dlib}!median@{median}}
\index{median@{median}!dlib@{dlib}}
\subsubsection[{median}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void dlib::median (T \& {\em one}, \/  T \& {\em two}, \/  T \& {\em three})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_af2608709700ae61f169fd4687e406267}
requires
\begin{DoxyItemize}
\item T implements operator$<$
\item T is swappable by a global swap() ensures
\item one is the median
\item one, two, and three is some permutation of one, two, and three. ! 
\end{DoxyItemize}\hypertarget{namespacedlib_a36bcf970b14e81d1c300283a52d64142}{
\index{dlib@{dlib}!put\_\-in\_\-range@{put\_\-in\_\-range}}
\index{put\_\-in\_\-range@{put\_\-in\_\-range}!dlib@{dlib}}
\subsubsection[{put\_\-in\_\-range}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ T dlib::put\_\-in\_\-range (const T \& {\em a}, \/  const T \& {\em b}, \/  const T \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a36bcf970b14e81d1c300283a52d64142}
requires
\begin{DoxyItemize}
\item T is a type that looks like double, float, int, or so forth ensures
\item if (val is within the range \mbox{[}a,b\mbox{]}) then
\begin{DoxyItemize}
\item returns val
\end{DoxyItemize}
\item else
\begin{DoxyItemize}
\item returns the end of the range \mbox{[}a,b\mbox{]} that is closest to val ! 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{namespacedlib_a603b4c76cedf8bff5975b76817f27eaa}{
\index{dlib@{dlib}!qsort\_\-array@{qsort\_\-array}}
\index{qsort\_\-array@{qsort\_\-array}!dlib@{dlib}}
\subsubsection[{qsort\_\-array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void dlib::qsort\_\-array (T \& {\em array}, \/  unsigned long {\em left}, \/  unsigned long {\em right})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a603b4c76cedf8bff5975b76817f27eaa}
requires
\begin{DoxyItemize}
\item T implements operator\mbox{[}\mbox{]}
\item the items in \hyperlink{classdlib_1_1array}{array} must be comparable by comp where comp is a function object with the same syntax as std::less$<$$>$
\item the items in \hyperlink{classdlib_1_1array}{array} must be swappable by a global swap()
\item left and right are within the bounds of \hyperlink{classdlib_1_1array}{array} i.e. \hyperlink{classdlib_1_1array}{array}\mbox{[}left\mbox{]} and \hyperlink{classdlib_1_1array}{array}\mbox{[}right\mbox{]} are valid elements
\item left $<$= right ensures
\item for all elements in array between and including left and right the ith element is $<$ the i+1 element
\item sorts using an insertion sort algorithm ! 
\end{DoxyItemize}\hypertarget{namespacedlib_add718e65e3023a2abd8eb04200e81b52}{
\index{dlib@{dlib}!serialize@{serialize}}
\index{serialize@{serialize}!dlib@{dlib}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::serialize (const hsi\_\-pixel \& {\em item}, \/  std::ostream \& {\em out})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_add718e65e3023a2abd8eb04200e81b52}
provides deserialization support for the \hyperlink{structdlib_1_1rgb__alpha__pixel}{rgb\_\-alpha\_\-pixel} struct ! \hypertarget{namespacedlib_abbbd5224f9387eef940579cdf3fd4a13}{
\index{dlib@{dlib}!serialize@{serialize}}
\index{serialize@{serialize}!dlib@{dlib}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::serialize (const rgb\_\-alpha\_\-pixel \& {\em item}, \/  std::ostream \& {\em out})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_abbbd5224f9387eef940579cdf3fd4a13}
provides deserialization support for the \hyperlink{structdlib_1_1bgr__pixel}{bgr\_\-pixel} struct ! \hypertarget{namespacedlib_aefd5ce982b258dc62d2c4a657278a492}{
\index{dlib@{dlib}!serialize@{serialize}}
\index{serialize@{serialize}!dlib@{dlib}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::serialize (const bgr\_\-pixel \& {\em item}, \/  std::ostream \& {\em out})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_aefd5ce982b258dc62d2c4a657278a492}
provides deserialization support for the \hyperlink{structdlib_1_1rgb__pixel}{rgb\_\-pixel} struct ! \hypertarget{namespacedlib_ac78b72e65600a0d25ac3224539794fc2}{
\index{dlib@{dlib}!serialize@{serialize}}
\index{serialize@{serialize}!dlib@{dlib}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void dlib::serialize (const rgb\_\-pixel \& {\em item}, \/  std::ostream \& {\em out})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_ac78b72e65600a0d25ac3224539794fc2}
requires
\begin{DoxyItemize}
\item pixel\_\-traits
\end{DoxyItemize}

must be defined ensures
\begin{DoxyItemize}
\item let val == min(new\_\-intensity, pixel\_\-traits$<$P$>$::max())
\item get\_\-pixel\_\-intensity(dest) == val
\item if (the dest pixel has an alpha channel) then
\begin{DoxyItemize}
\item dest.alpha == dest.alpha ! 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{namespacedlib_aa718d15067f15dd851a98eb1088131ae}{
\index{dlib@{dlib}!square\_\-root@{square\_\-root}}
\index{square\_\-root@{square\_\-root}!dlib@{dlib}}
\subsubsection[{square\_\-root}]{\setlength{\rightskip}{0pt plus 5cm}unsigned long dlib::square\_\-root (unsigned long {\em value})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_aa718d15067f15dd851a98eb1088131ae}
requires
\begin{DoxyItemize}
\item value $<$= 2$^\wedge$32 -\/ 1 ensures
\item returns the square root of value. if the square root is not an integer then it will be rounded up to the nearest integer. ! 
\end{DoxyItemize}\hypertarget{namespacedlib_a87847cba5edee8c23c0970bbe19fa3ce}{
\index{dlib@{dlib}!zero\_\-extend\_\-cast@{zero\_\-extend\_\-cast}}
\index{zero\_\-extend\_\-cast@{zero\_\-extend\_\-cast}!dlib@{dlib}}
\subsubsection[{zero\_\-extend\_\-cast}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename U $>$ T dlib::zero\_\-extend\_\-cast (const U {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacedlib_a87847cba5edee8c23c0970bbe19fa3ce}
ensures
\begin{DoxyItemize}
\item sizeof(unsigned\_\-type$<$T$>$::type) == sizeof(T)
\item unsigned\_\-type$<$T$>$::type is an unsigned integral type !
\end{DoxyItemize}

requires
\begin{DoxyItemize}
\item U and T are integral types ensures
\item let ut be a typedef for unsigned\_\-type$<$U$>$::type
\item return static\_\-cast$<$T$>$(static\_\-cast$<$ut$>$(val)); ! 
\end{DoxyItemize}